{"ast":null,"code":"import _objectSpread from \"C:/Users/PC/freelance-marketplace/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\n// functions\nexport function assertEqual(val) {\n  return val;\n}\nexport function assertNotEqual(val) {\n  return val;\n}\nexport function assertIs(_arg) {}\nexport function assertNever(_x) {\n  throw new Error();\n}\nexport function assert(_) {}\nexport function getEnumValues(entries) {\n  const numericValues = Object.values(entries).filter(v => typeof v === \"number\");\n  const values = Object.entries(entries).filter(_ref => {\n    let [k, _] = _ref;\n    return numericValues.indexOf(+k) === -1;\n  }).map(_ref2 => {\n    let [_, v] = _ref2;\n    return v;\n  });\n  return values;\n}\nexport function joinValues(array) {\n  let separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"|\";\n  return array.map(val => stringifyPrimitive(val)).join(separator);\n}\nexport function jsonStringifyReplacer(_, value) {\n  if (typeof value === \"bigint\") return value.toString();\n  return value;\n}\nexport function cached(getter) {\n  const set = false;\n  return {\n    get value() {\n      if (!set) {\n        const value = getter();\n        Object.defineProperty(this, \"value\", {\n          value\n        });\n        return value;\n      }\n      throw new Error(\"cached value already set\");\n    }\n  };\n}\nexport function nullish(input) {\n  return input === null || input === undefined;\n}\nexport function cleanRegex(source) {\n  const start = source.startsWith(\"^\") ? 1 : 0;\n  const end = source.endsWith(\"$\") ? source.length - 1 : source.length;\n  return source.slice(start, end);\n}\nexport function floatSafeRemainder(val, step) {\n  const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n  const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n  const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n  const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n  return valInt % stepInt / 10 ** decCount;\n}\nexport function defineLazy(object, key, getter) {\n  const set = false;\n  Object.defineProperty(object, key, {\n    get() {\n      if (!set) {\n        const value = getter();\n        object[key] = value;\n        return value;\n      }\n      throw new Error(\"cached value already set\");\n    },\n    set(v) {\n      Object.defineProperty(object, key, {\n        value: v\n        // configurable: true,\n      });\n      // object[key] = v;\n    },\n    configurable: true\n  });\n}\nexport function assignProp(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value,\n    writable: true,\n    enumerable: true,\n    configurable: true\n  });\n}\nexport function getElementAtPath(obj, path) {\n  if (!path) return obj;\n  return path.reduce((acc, key) => acc === null || acc === void 0 ? void 0 : acc[key], obj);\n}\nexport function promiseAllObject(promisesObj) {\n  const keys = Object.keys(promisesObj);\n  const promises = keys.map(key => promisesObj[key]);\n  return Promise.all(promises).then(results => {\n    const resolvedObj = {};\n    for (let i = 0; i < keys.length; i++) {\n      resolvedObj[keys[i]] = results[i];\n    }\n    return resolvedObj;\n  });\n}\nexport function randomString() {\n  let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n  const chars = \"abcdefghijklmnopqrstuvwxyz\";\n  let str = \"\";\n  for (let i = 0; i < length; i++) {\n    str += chars[Math.floor(Math.random() * chars.length)];\n  }\n  return str;\n}\nexport function esc(str) {\n  return JSON.stringify(str);\n}\nexport const captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : function () {};\nexport function isObject(data) {\n  return typeof data === \"object\" && data !== null && !Array.isArray(data);\n}\nexport const allowsEval = cached(() => {\n  var _navigator;\n  if (typeof navigator !== \"undefined\" && (_navigator = navigator) !== null && _navigator !== void 0 && (_navigator = _navigator.userAgent) !== null && _navigator !== void 0 && _navigator.includes(\"Cloudflare\")) {\n    return false;\n  }\n  try {\n    const F = Function;\n    new F(\"\");\n    return true;\n  } catch (_) {\n    return false;\n  }\n});\nexport function isPlainObject(o) {\n  if (isObject(o) === false) return false;\n  // modified constructor\n  const ctor = o.constructor;\n  if (ctor === undefined) return true;\n  // modified prototype\n  const prot = ctor.prototype;\n  if (isObject(prot) === false) return false;\n  // ctor doesn't have static `isPrototypeOf`\n  if (Object.prototype.hasOwnProperty.call(prot, \"isPrototypeOf\") === false) {\n    return false;\n  }\n  return true;\n}\nexport function numKeys(data) {\n  let keyCount = 0;\n  for (const key in data) {\n    if (Object.prototype.hasOwnProperty.call(data, key)) {\n      keyCount++;\n    }\n  }\n  return keyCount;\n}\nexport const getParsedType = data => {\n  const t = typeof data;\n  switch (t) {\n    case \"undefined\":\n      return \"undefined\";\n    case \"string\":\n      return \"string\";\n    case \"number\":\n      return Number.isNaN(data) ? \"nan\" : \"number\";\n    case \"boolean\":\n      return \"boolean\";\n    case \"function\":\n      return \"function\";\n    case \"bigint\":\n      return \"bigint\";\n    case \"symbol\":\n      return \"symbol\";\n    case \"object\":\n      if (Array.isArray(data)) {\n        return \"array\";\n      }\n      if (data === null) {\n        return \"null\";\n      }\n      if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n        return \"promise\";\n      }\n      if (typeof Map !== \"undefined\" && data instanceof Map) {\n        return \"map\";\n      }\n      if (typeof Set !== \"undefined\" && data instanceof Set) {\n        return \"set\";\n      }\n      if (typeof Date !== \"undefined\" && data instanceof Date) {\n        return \"date\";\n      }\n      if (typeof File !== \"undefined\" && data instanceof File) {\n        return \"file\";\n      }\n      return \"object\";\n    default:\n      throw new Error(\"Unknown data type: \".concat(t));\n  }\n};\nexport const propertyKeyTypes = new Set([\"string\", \"number\", \"symbol\"]);\nexport const primitiveTypes = new Set([\"string\", \"number\", \"bigint\", \"boolean\", \"symbol\", \"undefined\"]);\nexport function escapeRegex(str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n// zod-specific utils\nexport function clone(inst, def, params) {\n  const cl = new inst._zod.constr(def !== null && def !== void 0 ? def : inst._zod.def);\n  if (!def || params !== null && params !== void 0 && params.parent) cl._zod.parent = inst;\n  return cl;\n}\nexport function normalizeParams(_params) {\n  const params = _params;\n  if (!params) return {};\n  if (typeof params === \"string\") return {\n    error: () => params\n  };\n  if ((params === null || params === void 0 ? void 0 : params.message) !== undefined) {\n    if ((params === null || params === void 0 ? void 0 : params.error) !== undefined) throw new Error(\"Cannot specify both `message` and `error` params\");\n    params.error = params.message;\n  }\n  delete params.message;\n  if (typeof params.error === \"string\") return _objectSpread(_objectSpread({}, params), {}, {\n    error: () => params.error\n  });\n  return params;\n}\nexport function createTransparentProxy(getter) {\n  let target;\n  return new Proxy({}, {\n    get(_, prop, receiver) {\n      target !== null && target !== void 0 ? target : target = getter();\n      return Reflect.get(target, prop, receiver);\n    },\n    set(_, prop, value, receiver) {\n      target !== null && target !== void 0 ? target : target = getter();\n      return Reflect.set(target, prop, value, receiver);\n    },\n    has(_, prop) {\n      target !== null && target !== void 0 ? target : target = getter();\n      return Reflect.has(target, prop);\n    },\n    deleteProperty(_, prop) {\n      target !== null && target !== void 0 ? target : target = getter();\n      return Reflect.deleteProperty(target, prop);\n    },\n    ownKeys(_) {\n      target !== null && target !== void 0 ? target : target = getter();\n      return Reflect.ownKeys(target);\n    },\n    getOwnPropertyDescriptor(_, prop) {\n      target !== null && target !== void 0 ? target : target = getter();\n      return Reflect.getOwnPropertyDescriptor(target, prop);\n    },\n    defineProperty(_, prop, descriptor) {\n      target !== null && target !== void 0 ? target : target = getter();\n      return Reflect.defineProperty(target, prop, descriptor);\n    }\n  });\n}\nexport function stringifyPrimitive(value) {\n  if (typeof value === \"bigint\") return value.toString() + \"n\";\n  if (typeof value === \"string\") return \"\\\"\".concat(value, \"\\\"\");\n  return \"\".concat(value);\n}\nexport function optionalKeys(shape) {\n  return Object.keys(shape).filter(k => {\n    return shape[k]._zod.optin === \"optional\" && shape[k]._zod.optout === \"optional\";\n  });\n}\nexport const NUMBER_FORMAT_RANGES = {\n  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],\n  int32: [-2147483648, 2147483647],\n  uint32: [0, 4294967295],\n  float32: [-3.4028234663852886e38, 3.4028234663852886e38],\n  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]\n};\nexport const BIGINT_FORMAT_RANGES = {\n  int64: [/* @__PURE__*/BigInt(\"-9223372036854775808\"), /* @__PURE__*/BigInt(\"9223372036854775807\")],\n  uint64: [/* @__PURE__*/BigInt(0), /* @__PURE__*/BigInt(\"18446744073709551615\")]\n};\nexport function pick(schema, mask) {\n  const newShape = {};\n  const currDef = schema._zod.def; //.shape;\n  for (const key in mask) {\n    if (!(key in currDef.shape)) {\n      throw new Error(\"Unrecognized key: \\\"\".concat(key, \"\\\"\"));\n    }\n    if (!mask[key]) continue;\n    // pick key\n    newShape[key] = currDef.shape[key];\n  }\n  return clone(schema, _objectSpread(_objectSpread({}, schema._zod.def), {}, {\n    shape: newShape,\n    checks: []\n  }));\n}\nexport function omit(schema, mask) {\n  const newShape = _objectSpread({}, schema._zod.def.shape);\n  const currDef = schema._zod.def; //.shape;\n  for (const key in mask) {\n    if (!(key in currDef.shape)) {\n      throw new Error(\"Unrecognized key: \\\"\".concat(key, \"\\\"\"));\n    }\n    if (!mask[key]) continue;\n    delete newShape[key];\n  }\n  return clone(schema, _objectSpread(_objectSpread({}, schema._zod.def), {}, {\n    shape: newShape,\n    checks: []\n  }));\n}\nexport function extend(schema, shape) {\n  if (!isPlainObject(shape)) {\n    throw new Error(\"Invalid input to extend: expected a plain object\");\n  }\n  const def = _objectSpread(_objectSpread({}, schema._zod.def), {}, {\n    get shape() {\n      const _shape = _objectSpread(_objectSpread({}, schema._zod.def.shape), shape);\n      assignProp(this, \"shape\", _shape); // self-caching\n      return _shape;\n    },\n    checks: [] // delete existing checks\n  });\n  return clone(schema, def);\n}\nexport function merge(a, b) {\n  return clone(a, _objectSpread(_objectSpread({}, a._zod.def), {}, {\n    get shape() {\n      const _shape = _objectSpread(_objectSpread({}, a._zod.def.shape), b._zod.def.shape);\n      assignProp(this, \"shape\", _shape); // self-caching\n      return _shape;\n    },\n    catchall: b._zod.def.catchall,\n    checks: [] // delete existing checks\n  }));\n}\nexport function partial(Class, schema, mask) {\n  const oldShape = schema._zod.def.shape;\n  const shape = _objectSpread({}, oldShape);\n  if (mask) {\n    for (const key in mask) {\n      if (!(key in oldShape)) {\n        throw new Error(\"Unrecognized key: \\\"\".concat(key, \"\\\"\"));\n      }\n      if (!mask[key]) continue;\n      // if (oldShape[key]!._zod.optin === \"optional\") continue;\n      shape[key] = Class ? new Class({\n        type: \"optional\",\n        innerType: oldShape[key]\n      }) : oldShape[key];\n    }\n  } else {\n    for (const key in oldShape) {\n      // if (oldShape[key]!._zod.optin === \"optional\") continue;\n      shape[key] = Class ? new Class({\n        type: \"optional\",\n        innerType: oldShape[key]\n      }) : oldShape[key];\n    }\n  }\n  return clone(schema, _objectSpread(_objectSpread({}, schema._zod.def), {}, {\n    shape,\n    checks: []\n  }));\n}\nexport function required(Class, schema, mask) {\n  const oldShape = schema._zod.def.shape;\n  const shape = _objectSpread({}, oldShape);\n  if (mask) {\n    for (const key in mask) {\n      if (!(key in shape)) {\n        throw new Error(\"Unrecognized key: \\\"\".concat(key, \"\\\"\"));\n      }\n      if (!mask[key]) continue;\n      // overwrite with non-optional\n      shape[key] = new Class({\n        type: \"nonoptional\",\n        innerType: oldShape[key]\n      });\n    }\n  } else {\n    for (const key in oldShape) {\n      // overwrite with non-optional\n      shape[key] = new Class({\n        type: \"nonoptional\",\n        innerType: oldShape[key]\n      });\n    }\n  }\n  return clone(schema, _objectSpread(_objectSpread({}, schema._zod.def), {}, {\n    shape,\n    // optional: [],\n    checks: []\n  }));\n}\nexport function aborted(x) {\n  let startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  for (let i = startIndex; i < x.issues.length; i++) {\n    var _x$issues$i;\n    if (((_x$issues$i = x.issues[i]) === null || _x$issues$i === void 0 ? void 0 : _x$issues$i.continue) !== true) return true;\n  }\n  return false;\n}\nexport function prefixIssues(path, issues) {\n  return issues.map(iss => {\n    var _a$path;\n    var _a;\n    (_a$path = (_a = iss).path) !== null && _a$path !== void 0 ? _a$path : _a.path = [];\n    iss.path.unshift(path);\n    return iss;\n  });\n}\nexport function unwrapMessage(message) {\n  return typeof message === \"string\" ? message : message === null || message === void 0 ? void 0 : message.message;\n}\nexport function finalizeIssue(iss, ctx, config) {\n  var _iss$path;\n  const full = _objectSpread(_objectSpread({}, iss), {}, {\n    path: (_iss$path = iss.path) !== null && _iss$path !== void 0 ? _iss$path : []\n  });\n  // for backwards compatibility\n  if (!iss.message) {\n    var _ref3, _ref4, _ref5, _unwrapMessage, _iss$inst, _iss$inst$error, _ctx$error, _config$customError, _config$localeError;\n    const message = (_ref3 = (_ref4 = (_ref5 = (_unwrapMessage = unwrapMessage((_iss$inst = iss.inst) === null || _iss$inst === void 0 || (_iss$inst = _iss$inst._zod.def) === null || _iss$inst === void 0 || (_iss$inst$error = _iss$inst.error) === null || _iss$inst$error === void 0 ? void 0 : _iss$inst$error.call(_iss$inst, iss))) !== null && _unwrapMessage !== void 0 ? _unwrapMessage : unwrapMessage(ctx === null || ctx === void 0 || (_ctx$error = ctx.error) === null || _ctx$error === void 0 ? void 0 : _ctx$error.call(ctx, iss))) !== null && _ref5 !== void 0 ? _ref5 : unwrapMessage((_config$customError = config.customError) === null || _config$customError === void 0 ? void 0 : _config$customError.call(config, iss))) !== null && _ref4 !== void 0 ? _ref4 : unwrapMessage((_config$localeError = config.localeError) === null || _config$localeError === void 0 ? void 0 : _config$localeError.call(config, iss))) !== null && _ref3 !== void 0 ? _ref3 : \"Invalid input\";\n    full.message = message;\n  }\n  // delete (full as any).def;\n  delete full.inst;\n  delete full.continue;\n  if (!(ctx !== null && ctx !== void 0 && ctx.reportInput)) {\n    delete full.input;\n  }\n  return full;\n}\nexport function getSizableOrigin(input) {\n  if (input instanceof Set) return \"set\";\n  if (input instanceof Map) return \"map\";\n  if (input instanceof File) return \"file\";\n  return \"unknown\";\n}\nexport function getLengthableOrigin(input) {\n  if (Array.isArray(input)) return \"array\";\n  if (typeof input === \"string\") return \"string\";\n  return \"unknown\";\n}\nexport function issue() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  const [iss, input, inst] = args;\n  if (typeof iss === \"string\") {\n    return {\n      message: iss,\n      code: \"custom\",\n      input,\n      inst\n    };\n  }\n  return _objectSpread({}, iss);\n}\nexport function cleanEnum(obj) {\n  return Object.entries(obj).filter(_ref6 => {\n    let [k, _] = _ref6;\n    // return true if NaN, meaning it's not a number, thus a string key\n    return Number.isNaN(Number.parseInt(k, 10));\n  }).map(el => el[1]);\n}\n// instanceof\nexport class Class {\n  constructor() {}\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}