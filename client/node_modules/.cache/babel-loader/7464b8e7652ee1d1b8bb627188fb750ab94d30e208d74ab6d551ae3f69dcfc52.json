{"ast":null,"code":"import { $constructor } from \"./core.js\";\nimport * as util from \"./util.js\";\nconst initializer = (inst, def) => {\n  inst.name = \"$ZodError\";\n  Object.defineProperty(inst, \"_zod\", {\n    value: inst._zod,\n    enumerable: false\n  });\n  Object.defineProperty(inst, \"issues\", {\n    value: def,\n    enumerable: false\n  });\n  Object.defineProperty(inst, \"message\", {\n    get() {\n      return JSON.stringify(def, util.jsonStringifyReplacer, 2);\n    },\n    enumerable: true\n    // configurable: false,\n  });\n  Object.defineProperty(inst, \"toString\", {\n    value: () => inst.message,\n    enumerable: false\n  });\n};\nexport const $ZodError = $constructor(\"$ZodError\", initializer);\nexport const $ZodRealError = $constructor(\"$ZodError\", initializer, {\n  Parent: Error\n});\nexport function flattenError(error) {\n  let mapper = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : issue => issue.message;\n  const fieldErrors = {};\n  const formErrors = [];\n  for (const sub of error.issues) {\n    if (sub.path.length > 0) {\n      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n      fieldErrors[sub.path[0]].push(mapper(sub));\n    } else {\n      formErrors.push(mapper(sub));\n    }\n  }\n  return {\n    formErrors,\n    fieldErrors\n  };\n}\nexport function formatError(error, _mapper) {\n  const mapper = _mapper || function (issue) {\n    return issue.message;\n  };\n  const fieldErrors = {\n    _errors: []\n  };\n  const processError = error => {\n    for (const issue of error.issues) {\n      if (issue.code === \"invalid_union\" && issue.errors.length) {\n        issue.errors.map(issues => processError({\n          issues\n        }));\n      } else if (issue.code === \"invalid_key\") {\n        processError({\n          issues: issue.issues\n        });\n      } else if (issue.code === \"invalid_element\") {\n        processError({\n          issues: issue.issues\n        });\n      } else if (issue.path.length === 0) {\n        fieldErrors._errors.push(mapper(issue));\n      } else {\n        let curr = fieldErrors;\n        let i = 0;\n        while (i < issue.path.length) {\n          const el = issue.path[i];\n          const terminal = i === issue.path.length - 1;\n          if (!terminal) {\n            curr[el] = curr[el] || {\n              _errors: []\n            };\n          } else {\n            curr[el] = curr[el] || {\n              _errors: []\n            };\n            curr[el]._errors.push(mapper(issue));\n          }\n          curr = curr[el];\n          i++;\n        }\n      }\n    }\n  };\n  processError(error);\n  return fieldErrors;\n}\nexport function treeifyError(error, _mapper) {\n  const mapper = _mapper || function (issue) {\n    return issue.message;\n  };\n  const result = {\n    errors: []\n  };\n  const processError = function (error) {\n    let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var _a, _b;\n    for (const issue of error.issues) {\n      if (issue.code === \"invalid_union\" && issue.errors.length) {\n        // regular union error\n        issue.errors.map(issues => processError({\n          issues\n        }, issue.path));\n      } else if (issue.code === \"invalid_key\") {\n        processError({\n          issues: issue.issues\n        }, issue.path);\n      } else if (issue.code === \"invalid_element\") {\n        processError({\n          issues: issue.issues\n        }, issue.path);\n      } else {\n        const fullpath = [...path, ...issue.path];\n        if (fullpath.length === 0) {\n          result.errors.push(mapper(issue));\n          continue;\n        }\n        let curr = result;\n        let i = 0;\n        while (i < fullpath.length) {\n          const el = fullpath[i];\n          const terminal = i === fullpath.length - 1;\n          if (typeof el === \"string\") {\n            var _curr$properties, _a$el;\n            (_curr$properties = curr.properties) !== null && _curr$properties !== void 0 ? _curr$properties : curr.properties = {};\n            (_a$el = (_a = curr.properties)[el]) !== null && _a$el !== void 0 ? _a$el : _a[el] = {\n              errors: []\n            };\n            curr = curr.properties[el];\n          } else {\n            var _curr$items, _b$el;\n            (_curr$items = curr.items) !== null && _curr$items !== void 0 ? _curr$items : curr.items = [];\n            (_b$el = (_b = curr.items)[el]) !== null && _b$el !== void 0 ? _b$el : _b[el] = {\n              errors: []\n            };\n            curr = curr.items[el];\n          }\n          if (terminal) {\n            curr.errors.push(mapper(issue));\n          }\n          i++;\n        }\n      }\n    }\n  };\n  processError(error);\n  return result;\n}\n/** Format a ZodError as a human-readable string in the following form.\n *\n * From\n *\n * ```ts\n * ZodError {\n *   issues: [\n *     {\n *       expected: 'string',\n *       code: 'invalid_type',\n *       path: [ 'username' ],\n *       message: 'Invalid input: expected string'\n *     },\n *     {\n *       expected: 'number',\n *       code: 'invalid_type',\n *       path: [ 'favoriteNumbers', 1 ],\n *       message: 'Invalid input: expected number'\n *     }\n *   ];\n * }\n * ```\n *\n * to\n *\n * ```\n * username\n *   ✖ Expected number, received string at \"username\n * favoriteNumbers[0]\n *   ✖ Invalid input: expected number\n * ```\n */\nexport function toDotPath(path) {\n  const segs = [];\n  for (const seg of path) {\n    if (typeof seg === \"number\") segs.push(\"[\".concat(seg, \"]\"));else if (typeof seg === \"symbol\") segs.push(\"[\".concat(JSON.stringify(String(seg)), \"]\"));else if (/[^\\w$]/.test(seg)) segs.push(\"[\".concat(JSON.stringify(seg), \"]\"));else {\n      if (segs.length) segs.push(\".\");\n      segs.push(seg);\n    }\n  }\n  return segs.join(\"\");\n}\nexport function prettifyError(error) {\n  const lines = [];\n  // sort by path length\n  const issues = [...error.issues].sort((a, b) => a.path.length - b.path.length);\n  // Process each issue\n  for (const issue of issues) {\n    var _issue$path;\n    lines.push(\"\\u2716 \".concat(issue.message));\n    if ((_issue$path = issue.path) !== null && _issue$path !== void 0 && _issue$path.length) lines.push(\"  \\u2192 at \".concat(toDotPath(issue.path)));\n  }\n  // Convert Map to formatted string\n  return lines.join(\"\\n\");\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}