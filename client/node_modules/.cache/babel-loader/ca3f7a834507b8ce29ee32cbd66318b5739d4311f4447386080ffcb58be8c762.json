{"ast":null,"code":"import { $constructor } from \"./core.js\";\nimport * as util from \"./util.js\";\nconst initializer = (inst, def) => {\n  inst.name = \"$ZodError\";\n  Object.defineProperty(inst, \"_zod\", {\n    value: inst._zod,\n    enumerable: false\n  });\n  Object.defineProperty(inst, \"issues\", {\n    value: def,\n    enumerable: false\n  });\n  Object.defineProperty(inst, \"message\", {\n    get() {\n      return JSON.stringify(def, util.jsonStringifyReplacer, 2);\n    },\n    enumerable: true\n    // configurable: false,\n  });\n  Object.defineProperty(inst, \"toString\", {\n    value: () => inst.message,\n    enumerable: false\n  });\n};\nexport const $ZodError = $constructor(\"$ZodError\", initializer);\nexport const $ZodRealError = $constructor(\"$ZodError\", initializer, {\n  Parent: Error\n});\nexport function flattenError(error, mapper = issue => issue.message) {\n  const fieldErrors = {};\n  const formErrors = [];\n  for (const sub of error.issues) {\n    if (sub.path.length > 0) {\n      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n      fieldErrors[sub.path[0]].push(mapper(sub));\n    } else {\n      formErrors.push(mapper(sub));\n    }\n  }\n  return {\n    formErrors,\n    fieldErrors\n  };\n}\nexport function formatError(error, _mapper) {\n  const mapper = _mapper || function (issue) {\n    return issue.message;\n  };\n  const fieldErrors = {\n    _errors: []\n  };\n  const processError = error => {\n    for (const issue of error.issues) {\n      if (issue.code === \"invalid_union\" && issue.errors.length) {\n        issue.errors.map(issues => processError({\n          issues\n        }));\n      } else if (issue.code === \"invalid_key\") {\n        processError({\n          issues: issue.issues\n        });\n      } else if (issue.code === \"invalid_element\") {\n        processError({\n          issues: issue.issues\n        });\n      } else if (issue.path.length === 0) {\n        fieldErrors._errors.push(mapper(issue));\n      } else {\n        let curr = fieldErrors;\n        let i = 0;\n        while (i < issue.path.length) {\n          const el = issue.path[i];\n          const terminal = i === issue.path.length - 1;\n          if (!terminal) {\n            curr[el] = curr[el] || {\n              _errors: []\n            };\n          } else {\n            curr[el] = curr[el] || {\n              _errors: []\n            };\n            curr[el]._errors.push(mapper(issue));\n          }\n          curr = curr[el];\n          i++;\n        }\n      }\n    }\n  };\n  processError(error);\n  return fieldErrors;\n}\nexport function treeifyError(error, _mapper) {\n  const mapper = _mapper || function (issue) {\n    return issue.message;\n  };\n  const result = {\n    errors: []\n  };\n  const processError = (error, path = []) => {\n    var _a, _b;\n    for (const issue of error.issues) {\n      if (issue.code === \"invalid_union\" && issue.errors.length) {\n        // regular union error\n        issue.errors.map(issues => processError({\n          issues\n        }, issue.path));\n      } else if (issue.code === \"invalid_key\") {\n        processError({\n          issues: issue.issues\n        }, issue.path);\n      } else if (issue.code === \"invalid_element\") {\n        processError({\n          issues: issue.issues\n        }, issue.path);\n      } else {\n        const fullpath = [...path, ...issue.path];\n        if (fullpath.length === 0) {\n          result.errors.push(mapper(issue));\n          continue;\n        }\n        let curr = result;\n        let i = 0;\n        while (i < fullpath.length) {\n          const el = fullpath[i];\n          const terminal = i === fullpath.length - 1;\n          if (typeof el === \"string\") {\n            curr.properties ?? (curr.properties = {});\n            (_a = curr.properties)[el] ?? (_a[el] = {\n              errors: []\n            });\n            curr = curr.properties[el];\n          } else {\n            curr.items ?? (curr.items = []);\n            (_b = curr.items)[el] ?? (_b[el] = {\n              errors: []\n            });\n            curr = curr.items[el];\n          }\n          if (terminal) {\n            curr.errors.push(mapper(issue));\n          }\n          i++;\n        }\n      }\n    }\n  };\n  processError(error);\n  return result;\n}\n/** Format a ZodError as a human-readable string in the following form.\n *\n * From\n *\n * ```ts\n * ZodError {\n *   issues: [\n *     {\n *       expected: 'string',\n *       code: 'invalid_type',\n *       path: [ 'username' ],\n *       message: 'Invalid input: expected string'\n *     },\n *     {\n *       expected: 'number',\n *       code: 'invalid_type',\n *       path: [ 'favoriteNumbers', 1 ],\n *       message: 'Invalid input: expected number'\n *     }\n *   ];\n * }\n * ```\n *\n * to\n *\n * ```\n * username\n *   ✖ Expected number, received string at \"username\n * favoriteNumbers[0]\n *   ✖ Invalid input: expected number\n * ```\n */\nexport function toDotPath(path) {\n  const segs = [];\n  for (const seg of path) {\n    if (typeof seg === \"number\") segs.push(`[${seg}]`);else if (typeof seg === \"symbol\") segs.push(`[${JSON.stringify(String(seg))}]`);else if (/[^\\w$]/.test(seg)) segs.push(`[${JSON.stringify(seg)}]`);else {\n      if (segs.length) segs.push(\".\");\n      segs.push(seg);\n    }\n  }\n  return segs.join(\"\");\n}\nexport function prettifyError(error) {\n  const lines = [];\n  // sort by path length\n  const issues = [...error.issues].sort((a, b) => a.path.length - b.path.length);\n  // Process each issue\n  for (const issue of issues) {\n    lines.push(`✖ ${issue.message}`);\n    if (issue.path?.length) lines.push(`  → at ${toDotPath(issue.path)}`);\n  }\n  // Convert Map to formatted string\n  return lines.join(\"\\n\");\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}