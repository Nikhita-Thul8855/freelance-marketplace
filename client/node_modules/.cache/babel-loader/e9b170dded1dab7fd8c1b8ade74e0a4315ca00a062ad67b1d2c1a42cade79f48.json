{"ast":null,"code":"import * as checks from \"./checks.js\";\nimport * as schemas from \"./schemas.js\";\nimport * as util from \"./util.js\";\nexport function _string(Class, params) {\n  return new Class({\n    type: \"string\",\n    ...util.normalizeParams(params)\n  });\n}\nexport function _coercedString(Class, params) {\n  return new Class({\n    type: \"string\",\n    coerce: true,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _email(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"email\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _guid(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"guid\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _uuid(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"uuid\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _uuidv4(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"uuid\",\n    check: \"string_format\",\n    abort: false,\n    version: \"v4\",\n    ...util.normalizeParams(params)\n  });\n}\nexport function _uuidv6(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"uuid\",\n    check: \"string_format\",\n    abort: false,\n    version: \"v6\",\n    ...util.normalizeParams(params)\n  });\n}\nexport function _uuidv7(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"uuid\",\n    check: \"string_format\",\n    abort: false,\n    version: \"v7\",\n    ...util.normalizeParams(params)\n  });\n}\nexport function _url(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"url\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _emoji(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"emoji\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _nanoid(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"nanoid\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _cuid(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"cuid\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _cuid2(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"cuid2\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _ulid(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"ulid\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _xid(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"xid\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _ksuid(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"ksuid\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _ipv4(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"ipv4\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _ipv6(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"ipv6\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _cidrv4(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"cidrv4\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _cidrv6(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"cidrv6\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _base64(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"base64\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _base64url(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"base64url\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _e164(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"e164\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _jwt(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"jwt\",\n    check: \"string_format\",\n    abort: false,\n    ...util.normalizeParams(params)\n  });\n}\nexport const TimePrecision = {\n  Any: null,\n  Minute: -1,\n  Second: 0,\n  Millisecond: 3,\n  Microsecond: 6\n};\nexport function _isoDateTime(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"datetime\",\n    check: \"string_format\",\n    offset: false,\n    local: false,\n    precision: null,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _isoDate(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"date\",\n    check: \"string_format\",\n    ...util.normalizeParams(params)\n  });\n}\nexport function _isoTime(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"time\",\n    check: \"string_format\",\n    precision: null,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _isoDuration(Class, params) {\n  return new Class({\n    type: \"string\",\n    format: \"duration\",\n    check: \"string_format\",\n    ...util.normalizeParams(params)\n  });\n}\nexport function _number(Class, params) {\n  return new Class({\n    type: \"number\",\n    checks: [],\n    ...util.normalizeParams(params)\n  });\n}\nexport function _coercedNumber(Class, params) {\n  return new Class({\n    type: \"number\",\n    coerce: true,\n    checks: [],\n    ...util.normalizeParams(params)\n  });\n}\nexport function _int(Class, params) {\n  return new Class({\n    type: \"number\",\n    check: \"number_format\",\n    abort: false,\n    format: \"safeint\",\n    ...util.normalizeParams(params)\n  });\n}\nexport function _float32(Class, params) {\n  return new Class({\n    type: \"number\",\n    check: \"number_format\",\n    abort: false,\n    format: \"float32\",\n    ...util.normalizeParams(params)\n  });\n}\nexport function _float64(Class, params) {\n  return new Class({\n    type: \"number\",\n    check: \"number_format\",\n    abort: false,\n    format: \"float64\",\n    ...util.normalizeParams(params)\n  });\n}\nexport function _int32(Class, params) {\n  return new Class({\n    type: \"number\",\n    check: \"number_format\",\n    abort: false,\n    format: \"int32\",\n    ...util.normalizeParams(params)\n  });\n}\nexport function _uint32(Class, params) {\n  return new Class({\n    type: \"number\",\n    check: \"number_format\",\n    abort: false,\n    format: \"uint32\",\n    ...util.normalizeParams(params)\n  });\n}\nexport function _boolean(Class, params) {\n  return new Class({\n    type: \"boolean\",\n    ...util.normalizeParams(params)\n  });\n}\nexport function _coercedBoolean(Class, params) {\n  return new Class({\n    type: \"boolean\",\n    coerce: true,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _bigint(Class, params) {\n  return new Class({\n    type: \"bigint\",\n    ...util.normalizeParams(params)\n  });\n}\nexport function _coercedBigint(Class, params) {\n  return new Class({\n    type: \"bigint\",\n    coerce: true,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _int64(Class, params) {\n  return new Class({\n    type: \"bigint\",\n    check: \"bigint_format\",\n    abort: false,\n    format: \"int64\",\n    ...util.normalizeParams(params)\n  });\n}\nexport function _uint64(Class, params) {\n  return new Class({\n    type: \"bigint\",\n    check: \"bigint_format\",\n    abort: false,\n    format: \"uint64\",\n    ...util.normalizeParams(params)\n  });\n}\nexport function _symbol(Class, params) {\n  return new Class({\n    type: \"symbol\",\n    ...util.normalizeParams(params)\n  });\n}\nexport function _undefined(Class, params) {\n  return new Class({\n    type: \"undefined\",\n    ...util.normalizeParams(params)\n  });\n}\nexport function _null(Class, params) {\n  return new Class({\n    type: \"null\",\n    ...util.normalizeParams(params)\n  });\n}\nexport function _any(Class) {\n  return new Class({\n    type: \"any\"\n  });\n}\nexport function _unknown(Class) {\n  return new Class({\n    type: \"unknown\"\n  });\n}\nexport function _never(Class, params) {\n  return new Class({\n    type: \"never\",\n    ...util.normalizeParams(params)\n  });\n}\nexport function _void(Class, params) {\n  return new Class({\n    type: \"void\",\n    ...util.normalizeParams(params)\n  });\n}\nexport function _date(Class, params) {\n  return new Class({\n    type: \"date\",\n    ...util.normalizeParams(params)\n  });\n}\nexport function _coercedDate(Class, params) {\n  return new Class({\n    type: \"date\",\n    coerce: true,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _nan(Class, params) {\n  return new Class({\n    type: \"nan\",\n    ...util.normalizeParams(params)\n  });\n}\nexport function _lt(value, params) {\n  return new checks.$ZodCheckLessThan({\n    check: \"less_than\",\n    ...util.normalizeParams(params),\n    value,\n    inclusive: false\n  });\n}\nexport function _lte(value, params) {\n  return new checks.$ZodCheckLessThan({\n    check: \"less_than\",\n    ...util.normalizeParams(params),\n    value,\n    inclusive: true\n  });\n}\nexport { /** @deprecated Use `z.lte()` instead. */\n_lte as _max };\nexport function _gt(value, params) {\n  return new checks.$ZodCheckGreaterThan({\n    check: \"greater_than\",\n    ...util.normalizeParams(params),\n    value,\n    inclusive: false\n  });\n}\nexport function _gte(value, params) {\n  return new checks.$ZodCheckGreaterThan({\n    check: \"greater_than\",\n    ...util.normalizeParams(params),\n    value,\n    inclusive: true\n  });\n}\nexport { /** @deprecated Use `z.gte()` instead. */\n_gte as _min };\nexport function _positive(params) {\n  return _gt(0, params);\n}\n// negative\nexport function _negative(params) {\n  return _lt(0, params);\n}\n// nonpositive\nexport function _nonpositive(params) {\n  return _lte(0, params);\n}\n// nonnegative\nexport function _nonnegative(params) {\n  return _gte(0, params);\n}\nexport function _multipleOf(value, params) {\n  return new checks.$ZodCheckMultipleOf({\n    check: \"multiple_of\",\n    ...util.normalizeParams(params),\n    value\n  });\n}\nexport function _maxSize(maximum, params) {\n  return new checks.$ZodCheckMaxSize({\n    check: \"max_size\",\n    ...util.normalizeParams(params),\n    maximum\n  });\n}\nexport function _minSize(minimum, params) {\n  return new checks.$ZodCheckMinSize({\n    check: \"min_size\",\n    ...util.normalizeParams(params),\n    minimum\n  });\n}\nexport function _size(size, params) {\n  return new checks.$ZodCheckSizeEquals({\n    check: \"size_equals\",\n    ...util.normalizeParams(params),\n    size\n  });\n}\nexport function _maxLength(maximum, params) {\n  const ch = new checks.$ZodCheckMaxLength({\n    check: \"max_length\",\n    ...util.normalizeParams(params),\n    maximum\n  });\n  return ch;\n}\nexport function _minLength(minimum, params) {\n  return new checks.$ZodCheckMinLength({\n    check: \"min_length\",\n    ...util.normalizeParams(params),\n    minimum\n  });\n}\nexport function _length(length, params) {\n  return new checks.$ZodCheckLengthEquals({\n    check: \"length_equals\",\n    ...util.normalizeParams(params),\n    length\n  });\n}\nexport function _regex(pattern, params) {\n  return new checks.$ZodCheckRegex({\n    check: \"string_format\",\n    format: \"regex\",\n    ...util.normalizeParams(params),\n    pattern\n  });\n}\nexport function _lowercase(params) {\n  return new checks.$ZodCheckLowerCase({\n    check: \"string_format\",\n    format: \"lowercase\",\n    ...util.normalizeParams(params)\n  });\n}\nexport function _uppercase(params) {\n  return new checks.$ZodCheckUpperCase({\n    check: \"string_format\",\n    format: \"uppercase\",\n    ...util.normalizeParams(params)\n  });\n}\nexport function _includes(includes, params) {\n  return new checks.$ZodCheckIncludes({\n    check: \"string_format\",\n    format: \"includes\",\n    ...util.normalizeParams(params),\n    includes\n  });\n}\nexport function _startsWith(prefix, params) {\n  return new checks.$ZodCheckStartsWith({\n    check: \"string_format\",\n    format: \"starts_with\",\n    ...util.normalizeParams(params),\n    prefix\n  });\n}\nexport function _endsWith(suffix, params) {\n  return new checks.$ZodCheckEndsWith({\n    check: \"string_format\",\n    format: \"ends_with\",\n    ...util.normalizeParams(params),\n    suffix\n  });\n}\nexport function _property(property, schema, params) {\n  return new checks.$ZodCheckProperty({\n    check: \"property\",\n    property,\n    schema,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _mime(types, params) {\n  return new checks.$ZodCheckMimeType({\n    check: \"mime_type\",\n    mime: types,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _overwrite(tx) {\n  return new checks.$ZodCheckOverwrite({\n    check: \"overwrite\",\n    tx\n  });\n}\n// normalize\nexport function _normalize(form) {\n  return _overwrite(input => input.normalize(form));\n}\n// trim\nexport function _trim() {\n  return _overwrite(input => input.trim());\n}\n// toLowerCase\nexport function _toLowerCase() {\n  return _overwrite(input => input.toLowerCase());\n}\n// toUpperCase\nexport function _toUpperCase() {\n  return _overwrite(input => input.toUpperCase());\n}\nexport function _array(Class, element, params) {\n  return new Class({\n    type: \"array\",\n    element,\n    // get element() {\n    //   return element;\n    // },\n    ...util.normalizeParams(params)\n  });\n}\nexport function _union(Class, options, params) {\n  return new Class({\n    type: \"union\",\n    options,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _discriminatedUnion(Class, discriminator, options, params) {\n  return new Class({\n    type: \"union\",\n    options,\n    discriminator,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _intersection(Class, left, right) {\n  return new Class({\n    type: \"intersection\",\n    left,\n    right\n  });\n}\n// export function _tuple(\n//   Class: util.SchemaClass<schemas.$ZodTuple>,\n//   items: [],\n//   params?: string | $ZodTupleParams\n// ): schemas.$ZodTuple<[], null>;\nexport function _tuple(Class, items, _paramsOrRest, _params) {\n  const hasRest = _paramsOrRest instanceof schemas.$ZodType;\n  const params = hasRest ? _params : _paramsOrRest;\n  const rest = hasRest ? _paramsOrRest : null;\n  return new Class({\n    type: \"tuple\",\n    items,\n    rest,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _record(Class, keyType, valueType, params) {\n  return new Class({\n    type: \"record\",\n    keyType,\n    valueType,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _map(Class, keyType, valueType, params) {\n  return new Class({\n    type: \"map\",\n    keyType,\n    valueType,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _set(Class, valueType, params) {\n  return new Class({\n    type: \"set\",\n    valueType,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _enum(Class, values, params) {\n  const entries = Array.isArray(values) ? Object.fromEntries(values.map(v => [v, v])) : values;\n  // if (Array.isArray(values)) {\n  //   for (const value of values) {\n  //     entries[value] = value;\n  //   }\n  // } else {\n  //   Object.assign(entries, values);\n  // }\n  // const entries: util.EnumLike = {};\n  // for (const val of values) {\n  //   entries[val] = val;\n  // }\n  return new Class({\n    type: \"enum\",\n    entries,\n    ...util.normalizeParams(params)\n  });\n}\n/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.\n *\n * ```ts\n * enum Colors { red, green, blue }\n * z.enum(Colors);\n * ```\n */\nexport function _nativeEnum(Class, entries, params) {\n  return new Class({\n    type: \"enum\",\n    entries,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _literal(Class, value, params) {\n  return new Class({\n    type: \"literal\",\n    values: Array.isArray(value) ? value : [value],\n    ...util.normalizeParams(params)\n  });\n}\nexport function _file(Class, params) {\n  return new Class({\n    type: \"file\",\n    ...util.normalizeParams(params)\n  });\n}\nexport function _transform(Class, fn) {\n  return new Class({\n    type: \"transform\",\n    transform: fn\n  });\n}\nexport function _optional(Class, innerType) {\n  return new Class({\n    type: \"optional\",\n    innerType\n  });\n}\nexport function _nullable(Class, innerType) {\n  return new Class({\n    type: \"nullable\",\n    innerType\n  });\n}\nexport function _default(Class, innerType, defaultValue) {\n  return new Class({\n    type: \"default\",\n    innerType,\n    get defaultValue() {\n      return typeof defaultValue === \"function\" ? defaultValue() : defaultValue;\n    }\n  });\n}\nexport function _nonoptional(Class, innerType, params) {\n  return new Class({\n    type: \"nonoptional\",\n    innerType,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _success(Class, innerType) {\n  return new Class({\n    type: \"success\",\n    innerType\n  });\n}\nexport function _catch(Class, innerType, catchValue) {\n  return new Class({\n    type: \"catch\",\n    innerType,\n    catchValue: typeof catchValue === \"function\" ? catchValue : () => catchValue\n  });\n}\nexport function _pipe(Class, in_, out) {\n  return new Class({\n    type: \"pipe\",\n    in: in_,\n    out\n  });\n}\nexport function _readonly(Class, innerType) {\n  return new Class({\n    type: \"readonly\",\n    innerType\n  });\n}\nexport function _templateLiteral(Class, parts, params) {\n  return new Class({\n    type: \"template_literal\",\n    parts,\n    ...util.normalizeParams(params)\n  });\n}\nexport function _lazy(Class, getter) {\n  return new Class({\n    type: \"lazy\",\n    getter\n  });\n}\nexport function _promise(Class, innerType) {\n  return new Class({\n    type: \"promise\",\n    innerType\n  });\n}\nexport function _custom(Class, fn, _params) {\n  const norm = util.normalizeParams(_params);\n  norm.abort ?? (norm.abort = true); // default to abort:false\n  const schema = new Class({\n    type: \"custom\",\n    check: \"custom\",\n    fn: fn,\n    ...norm\n  });\n  return schema;\n}\n// export function _refine<T>(\n//   Class: util.SchemaClass<schemas.$ZodCustom>,\n//   fn: (arg: NoInfer<T>) => util.MaybeAsync<unknown>,\n//   _params: string | $ZodCustomParams = {}\n// ): checks.$ZodCheck<T> {\n//   return _custom(Class, fn, _params);\n// }\n// same as _custom but defaults to abort:false\nexport function _refine(Class, fn, _params) {\n  const schema = new Class({\n    type: \"custom\",\n    check: \"custom\",\n    fn: fn,\n    ...util.normalizeParams(_params)\n  });\n  return schema;\n}\nexport function _stringbool(Classes, _params) {\n  const params = util.normalizeParams(_params);\n  let truthyArray = params.truthy ?? [\"true\", \"1\", \"yes\", \"on\", \"y\", \"enabled\"];\n  let falsyArray = params.falsy ?? [\"false\", \"0\", \"no\", \"off\", \"n\", \"disabled\"];\n  if (params.case !== \"sensitive\") {\n    truthyArray = truthyArray.map(v => typeof v === \"string\" ? v.toLowerCase() : v);\n    falsyArray = falsyArray.map(v => typeof v === \"string\" ? v.toLowerCase() : v);\n  }\n  const truthySet = new Set(truthyArray);\n  const falsySet = new Set(falsyArray);\n  const _Pipe = Classes.Pipe ?? schemas.$ZodPipe;\n  const _Boolean = Classes.Boolean ?? schemas.$ZodBoolean;\n  const _String = Classes.String ?? schemas.$ZodString;\n  const _Transform = Classes.Transform ?? schemas.$ZodTransform;\n  const tx = new _Transform({\n    type: \"transform\",\n    transform: (input, payload) => {\n      let data = input;\n      if (params.case !== \"sensitive\") data = data.toLowerCase();\n      if (truthySet.has(data)) {\n        return true;\n      } else if (falsySet.has(data)) {\n        return false;\n      } else {\n        payload.issues.push({\n          code: \"invalid_value\",\n          expected: \"stringbool\",\n          values: [...truthySet, ...falsySet],\n          input: payload.value,\n          inst: tx\n        });\n        return {};\n      }\n    },\n    error: params.error\n  });\n  // params.error;\n  const innerPipe = new _Pipe({\n    type: \"pipe\",\n    in: new _String({\n      type: \"string\",\n      error: params.error\n    }),\n    out: tx,\n    error: params.error\n  });\n  const outerPipe = new _Pipe({\n    type: \"pipe\",\n    in: innerPipe,\n    out: new _Boolean({\n      type: \"boolean\",\n      error: params.error\n    }),\n    error: params.error\n  });\n  return outerPipe;\n}\nexport function _stringFormat(Class, format, fnOrRegex, _params = {}) {\n  const params = util.normalizeParams(_params);\n  const def = {\n    ...util.normalizeParams(_params),\n    check: \"string_format\",\n    type: \"string\",\n    format,\n    fn: typeof fnOrRegex === \"function\" ? fnOrRegex : val => fnOrRegex.test(val),\n    ...params\n  };\n  if (fnOrRegex instanceof RegExp) {\n    def.pattern = fnOrRegex;\n  }\n  const inst = new Class(def);\n  return inst;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}