{"ast":null,"code":"import * as checks from \"./checks.js\";\nimport * as core from \"./core.js\";\nimport { Doc } from \"./doc.js\";\nimport { safeParse, safeParseAsync } from \"./parse.js\";\nimport * as regexes from \"./regexes.js\";\nimport * as util from \"./util.js\";\nimport { version } from \"./versions.js\";\nexport const $ZodType = /*@__PURE__*/core.$constructor(\"$ZodType\", (inst, def) => {\n  var _a;\n  inst ?? (inst = {});\n  inst._zod.def = def; // set _def property\n  inst._zod.bag = inst._zod.bag || {}; // initialize _bag object\n  inst._zod.version = version;\n  const checks = [...(inst._zod.def.checks ?? [])];\n  // if inst is itself a checks.$ZodCheck, run it as a check\n  if (inst._zod.traits.has(\"$ZodCheck\")) {\n    checks.unshift(inst);\n  }\n  //\n  for (const ch of checks) {\n    for (const fn of ch._zod.onattach) {\n      fn(inst);\n    }\n  }\n  if (checks.length === 0) {\n    // deferred initializer\n    // inst._zod.parse is not yet defined\n    (_a = inst._zod).deferred ?? (_a.deferred = []);\n    inst._zod.deferred?.push(() => {\n      inst._zod.run = inst._zod.parse;\n    });\n  } else {\n    const runChecks = (payload, checks, ctx) => {\n      let isAborted = util.aborted(payload);\n      let asyncResult;\n      for (const ch of checks) {\n        if (ch._zod.def.when) {\n          const shouldRun = ch._zod.def.when(payload);\n          if (!shouldRun) continue;\n        } else if (isAborted) {\n          continue;\n        }\n        const currLen = payload.issues.length;\n        const _ = ch._zod.check(payload);\n        if (_ instanceof Promise && ctx?.async === false) {\n          throw new core.$ZodAsyncError();\n        }\n        if (asyncResult || _ instanceof Promise) {\n          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {\n            await _;\n            const nextLen = payload.issues.length;\n            if (nextLen === currLen) return;\n            if (!isAborted) isAborted = util.aborted(payload, currLen);\n          });\n        } else {\n          const nextLen = payload.issues.length;\n          if (nextLen === currLen) continue;\n          if (!isAborted) isAborted = util.aborted(payload, currLen);\n        }\n      }\n      if (asyncResult) {\n        return asyncResult.then(() => {\n          return payload;\n        });\n      }\n      return payload;\n    };\n    inst._zod.run = (payload, ctx) => {\n      const result = inst._zod.parse(payload, ctx);\n      if (result instanceof Promise) {\n        if (ctx.async === false) throw new core.$ZodAsyncError();\n        return result.then(result => runChecks(result, checks, ctx));\n      }\n      return runChecks(result, checks, ctx);\n    };\n  }\n  inst[\"~standard\"] = {\n    validate: value => {\n      try {\n        const r = safeParse(inst, value);\n        return r.success ? {\n          value: r.data\n        } : {\n          issues: r.error?.issues\n        };\n      } catch (_) {\n        return safeParseAsync(inst, value).then(r => r.success ? {\n          value: r.data\n        } : {\n          issues: r.error?.issues\n        });\n      }\n    },\n    vendor: \"zod\",\n    version: 1\n  };\n});\nexport { clone } from \"./util.js\";\nexport const $ZodString = /*@__PURE__*/core.$constructor(\"$ZodString\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = [...(inst?._zod.bag?.patterns ?? [])].pop() ?? regexes.string(inst._zod.bag);\n  inst._zod.parse = (payload, _) => {\n    if (def.coerce) try {\n      payload.value = String(payload.value);\n    } catch (_) {}\n    if (typeof payload.value === \"string\") return payload;\n    payload.issues.push({\n      expected: \"string\",\n      code: \"invalid_type\",\n      input: payload.value,\n      inst\n    });\n    return payload;\n  };\n});\nexport const $ZodStringFormat = /*@__PURE__*/core.$constructor(\"$ZodStringFormat\", (inst, def) => {\n  // check initialization must come first\n  checks.$ZodCheckStringFormat.init(inst, def);\n  $ZodString.init(inst, def);\n});\nexport const $ZodGUID = /*@__PURE__*/core.$constructor(\"$ZodGUID\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.guid);\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodUUID = /*@__PURE__*/core.$constructor(\"$ZodUUID\", (inst, def) => {\n  if (def.version) {\n    const versionMap = {\n      v1: 1,\n      v2: 2,\n      v3: 3,\n      v4: 4,\n      v5: 5,\n      v6: 6,\n      v7: 7,\n      v8: 8\n    };\n    const v = versionMap[def.version];\n    if (v === undefined) throw new Error(`Invalid UUID version: \"${def.version}\"`);\n    def.pattern ?? (def.pattern = regexes.uuid(v));\n  } else def.pattern ?? (def.pattern = regexes.uuid());\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodEmail = /*@__PURE__*/core.$constructor(\"$ZodEmail\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.email);\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodURL = /*@__PURE__*/core.$constructor(\"$ZodURL\", (inst, def) => {\n  $ZodStringFormat.init(inst, def);\n  inst._zod.check = payload => {\n    try {\n      const orig = payload.value;\n      const url = new URL(orig);\n      const href = url.href;\n      if (def.hostname) {\n        def.hostname.lastIndex = 0;\n        if (!def.hostname.test(url.hostname)) {\n          payload.issues.push({\n            code: \"invalid_format\",\n            format: \"url\",\n            note: \"Invalid hostname\",\n            pattern: regexes.hostname.source,\n            input: payload.value,\n            inst,\n            continue: !def.abort\n          });\n        }\n      }\n      if (def.protocol) {\n        def.protocol.lastIndex = 0;\n        if (!def.protocol.test(url.protocol.endsWith(\":\") ? url.protocol.slice(0, -1) : url.protocol)) {\n          payload.issues.push({\n            code: \"invalid_format\",\n            format: \"url\",\n            note: \"Invalid protocol\",\n            pattern: def.protocol.source,\n            input: payload.value,\n            inst,\n            continue: !def.abort\n          });\n        }\n      }\n      // payload.value = url.href;\n      if (!orig.endsWith(\"/\") && href.endsWith(\"/\")) {\n        payload.value = href.slice(0, -1);\n      } else {\n        payload.value = href;\n      }\n      return;\n    } catch (_) {\n      payload.issues.push({\n        code: \"invalid_format\",\n        format: \"url\",\n        input: payload.value,\n        inst,\n        continue: !def.abort\n      });\n    }\n  };\n});\nexport const $ZodEmoji = /*@__PURE__*/core.$constructor(\"$ZodEmoji\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.emoji());\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodNanoID = /*@__PURE__*/core.$constructor(\"$ZodNanoID\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.nanoid);\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodCUID = /*@__PURE__*/core.$constructor(\"$ZodCUID\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.cuid);\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodCUID2 = /*@__PURE__*/core.$constructor(\"$ZodCUID2\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.cuid2);\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodULID = /*@__PURE__*/core.$constructor(\"$ZodULID\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.ulid);\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodXID = /*@__PURE__*/core.$constructor(\"$ZodXID\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.xid);\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodKSUID = /*@__PURE__*/core.$constructor(\"$ZodKSUID\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.ksuid);\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodISODateTime = /*@__PURE__*/core.$constructor(\"$ZodISODateTime\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.datetime(def));\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodISODate = /*@__PURE__*/core.$constructor(\"$ZodISODate\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.date);\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodISOTime = /*@__PURE__*/core.$constructor(\"$ZodISOTime\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.time(def));\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodISODuration = /*@__PURE__*/core.$constructor(\"$ZodISODuration\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.duration);\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodIPv4 = /*@__PURE__*/core.$constructor(\"$ZodIPv4\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.ipv4);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.onattach.push(inst => {\n    const bag = inst._zod.bag;\n    bag.format = `ipv4`;\n  });\n});\nexport const $ZodIPv6 = /*@__PURE__*/core.$constructor(\"$ZodIPv6\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.ipv6);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.onattach.push(inst => {\n    const bag = inst._zod.bag;\n    bag.format = `ipv6`;\n  });\n  inst._zod.check = payload => {\n    try {\n      new URL(`http://[${payload.value}]`);\n      // return;\n    } catch {\n      payload.issues.push({\n        code: \"invalid_format\",\n        format: \"ipv6\",\n        input: payload.value,\n        inst,\n        continue: !def.abort\n      });\n    }\n  };\n});\nexport const $ZodCIDRv4 = /*@__PURE__*/core.$constructor(\"$ZodCIDRv4\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.cidrv4);\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodCIDRv6 = /*@__PURE__*/core.$constructor(\"$ZodCIDRv6\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.cidrv6); // not used for validation\n  $ZodStringFormat.init(inst, def);\n  inst._zod.check = payload => {\n    const [address, prefix] = payload.value.split(\"/\");\n    try {\n      if (!prefix) throw new Error();\n      const prefixNum = Number(prefix);\n      if (`${prefixNum}` !== prefix) throw new Error();\n      if (prefixNum < 0 || prefixNum > 128) throw new Error();\n      new URL(`http://[${address}]`);\n    } catch {\n      payload.issues.push({\n        code: \"invalid_format\",\n        format: \"cidrv6\",\n        input: payload.value,\n        inst,\n        continue: !def.abort\n      });\n    }\n  };\n});\n//////////////////////////////   ZodBase64   //////////////////////////////\nexport function isValidBase64(data) {\n  if (data === \"\") return true;\n  if (data.length % 4 !== 0) return false;\n  try {\n    atob(data);\n    return true;\n  } catch {\n    return false;\n  }\n}\nexport const $ZodBase64 = /*@__PURE__*/core.$constructor(\"$ZodBase64\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.base64);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.onattach.push(inst => {\n    inst._zod.bag.contentEncoding = \"base64\";\n  });\n  inst._zod.check = payload => {\n    if (isValidBase64(payload.value)) return;\n    payload.issues.push({\n      code: \"invalid_format\",\n      format: \"base64\",\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\n//////////////////////////////   ZodBase64   //////////////////////////////\nexport function isValidBase64URL(data) {\n  if (!regexes.base64url.test(data)) return false;\n  const base64 = data.replace(/[-_]/g, c => c === \"-\" ? \"+\" : \"/\");\n  const padded = base64.padEnd(Math.ceil(base64.length / 4) * 4, \"=\");\n  return isValidBase64(padded);\n}\nexport const $ZodBase64URL = /*@__PURE__*/core.$constructor(\"$ZodBase64URL\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.base64url);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.onattach.push(inst => {\n    inst._zod.bag.contentEncoding = \"base64url\";\n  });\n  inst._zod.check = payload => {\n    if (isValidBase64URL(payload.value)) return;\n    payload.issues.push({\n      code: \"invalid_format\",\n      format: \"base64url\",\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nexport const $ZodE164 = /*@__PURE__*/core.$constructor(\"$ZodE164\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.e164);\n  $ZodStringFormat.init(inst, def);\n});\n//////////////////////////////   ZodJWT   //////////////////////////////\nexport function isValidJWT(token, algorithm = null) {\n  try {\n    const tokensParts = token.split(\".\");\n    if (tokensParts.length !== 3) return false;\n    const [header] = tokensParts;\n    if (!header) return false;\n    const parsedHeader = JSON.parse(atob(header));\n    if (\"typ\" in parsedHeader && parsedHeader?.typ !== \"JWT\") return false;\n    if (!parsedHeader.alg) return false;\n    if (algorithm && (!(\"alg\" in parsedHeader) || parsedHeader.alg !== algorithm)) return false;\n    return true;\n  } catch {\n    return false;\n  }\n}\nexport const $ZodJWT = /*@__PURE__*/core.$constructor(\"$ZodJWT\", (inst, def) => {\n  $ZodStringFormat.init(inst, def);\n  inst._zod.check = payload => {\n    if (isValidJWT(payload.value, def.alg)) return;\n    payload.issues.push({\n      code: \"invalid_format\",\n      format: \"jwt\",\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nexport const $ZodCustomStringFormat = /*@__PURE__*/core.$constructor(\"$ZodCustomStringFormat\", (inst, def) => {\n  $ZodStringFormat.init(inst, def);\n  inst._zod.check = payload => {\n    if (def.fn(payload.value)) return;\n    payload.issues.push({\n      code: \"invalid_format\",\n      format: def.format,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nexport const $ZodNumber = /*@__PURE__*/core.$constructor(\"$ZodNumber\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = inst._zod.bag.pattern ?? regexes.number;\n  inst._zod.parse = (payload, _ctx) => {\n    if (def.coerce) try {\n      payload.value = Number(payload.value);\n    } catch (_) {}\n    const input = payload.value;\n    if (typeof input === \"number\" && !Number.isNaN(input) && Number.isFinite(input)) {\n      return payload;\n    }\n    const received = typeof input === \"number\" ? Number.isNaN(input) ? \"NaN\" : !Number.isFinite(input) ? \"Infinity\" : undefined : undefined;\n    payload.issues.push({\n      expected: \"number\",\n      code: \"invalid_type\",\n      input,\n      inst,\n      ...(received ? {\n        received\n      } : {})\n    });\n    return payload;\n  };\n});\nexport const $ZodNumberFormat = /*@__PURE__*/core.$constructor(\"$ZodNumber\", (inst, def) => {\n  checks.$ZodCheckNumberFormat.init(inst, def);\n  $ZodNumber.init(inst, def); // no format checksp\n});\nexport const $ZodBoolean = /*@__PURE__*/core.$constructor(\"$ZodBoolean\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = regexes.boolean;\n  inst._zod.parse = (payload, _ctx) => {\n    if (def.coerce) try {\n      payload.value = Boolean(payload.value);\n    } catch (_) {}\n    const input = payload.value;\n    if (typeof input === \"boolean\") return payload;\n    payload.issues.push({\n      expected: \"boolean\",\n      code: \"invalid_type\",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nexport const $ZodBigInt = /*@__PURE__*/core.$constructor(\"$ZodBigInt\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = regexes.bigint;\n  inst._zod.parse = (payload, _ctx) => {\n    if (def.coerce) try {\n      payload.value = BigInt(payload.value);\n    } catch (_) {}\n    if (typeof payload.value === \"bigint\") return payload;\n    payload.issues.push({\n      expected: \"bigint\",\n      code: \"invalid_type\",\n      input: payload.value,\n      inst\n    });\n    return payload;\n  };\n});\nexport const $ZodBigIntFormat = /*@__PURE__*/core.$constructor(\"$ZodBigInt\", (inst, def) => {\n  checks.$ZodCheckBigIntFormat.init(inst, def);\n  $ZodBigInt.init(inst, def); // no format checks\n});\nexport const $ZodSymbol = /*@__PURE__*/core.$constructor(\"$ZodSymbol\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (typeof input === \"symbol\") return payload;\n    payload.issues.push({\n      expected: \"symbol\",\n      code: \"invalid_type\",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nexport const $ZodUndefined = /*@__PURE__*/core.$constructor(\"$ZodUndefined\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = regexes.undefined;\n  inst._zod.values = new Set([undefined]);\n  inst._zod.optin = \"optional\";\n  inst._zod.optout = \"optional\";\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (typeof input === \"undefined\") return payload;\n    payload.issues.push({\n      expected: \"undefined\",\n      code: \"invalid_type\",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nexport const $ZodNull = /*@__PURE__*/core.$constructor(\"$ZodNull\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = regexes.null;\n  inst._zod.values = new Set([null]);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (input === null) return payload;\n    payload.issues.push({\n      expected: \"null\",\n      code: \"invalid_type\",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nexport const $ZodAny = /*@__PURE__*/core.$constructor(\"$ZodAny\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = payload => payload;\n});\nexport const $ZodUnknown = /*@__PURE__*/core.$constructor(\"$ZodUnknown\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = payload => payload;\n});\nexport const $ZodNever = /*@__PURE__*/core.$constructor(\"$ZodNever\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    payload.issues.push({\n      expected: \"never\",\n      code: \"invalid_type\",\n      input: payload.value,\n      inst\n    });\n    return payload;\n  };\n});\nexport const $ZodVoid = /*@__PURE__*/core.$constructor(\"$ZodVoid\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (typeof input === \"undefined\") return payload;\n    payload.issues.push({\n      expected: \"void\",\n      code: \"invalid_type\",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nexport const $ZodDate = /*@__PURE__*/core.$constructor(\"$ZodDate\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    if (def.coerce) {\n      try {\n        payload.value = new Date(payload.value);\n      } catch (_err) {}\n    }\n    const input = payload.value;\n    const isDate = input instanceof Date;\n    const isValidDate = isDate && !Number.isNaN(input.getTime());\n    if (isValidDate) return payload;\n    payload.issues.push({\n      expected: \"date\",\n      code: \"invalid_type\",\n      input,\n      ...(isDate ? {\n        received: \"Invalid Date\"\n      } : {}),\n      inst\n    });\n    return payload;\n  };\n});\nfunction handleArrayResult(result, final, index) {\n  if (result.issues.length) {\n    final.issues.push(...util.prefixIssues(index, result.issues));\n  }\n  final.value[index] = result.value;\n}\nexport const $ZodArray = /*@__PURE__*/core.$constructor(\"$ZodArray\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!Array.isArray(input)) {\n      payload.issues.push({\n        expected: \"array\",\n        code: \"invalid_type\",\n        input,\n        inst\n      });\n      return payload;\n    }\n    payload.value = Array(input.length);\n    const proms = [];\n    for (let i = 0; i < input.length; i++) {\n      const item = input[i];\n      const result = def.element._zod.run({\n        value: item,\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        proms.push(result.then(result => handleArrayResult(result, payload, i)));\n      } else {\n        handleArrayResult(result, payload, i);\n      }\n    }\n    if (proms.length) {\n      return Promise.all(proms).then(() => payload);\n    }\n    return payload; //handleArrayResultsAsync(parseResults, final);\n  };\n});\nfunction handleObjectResult(result, final, key) {\n  // if(isOptional)\n  if (result.issues.length) {\n    final.issues.push(...util.prefixIssues(key, result.issues));\n  }\n  final.value[key] = result.value;\n}\nfunction handleOptionalObjectResult(result, final, key, input) {\n  if (result.issues.length) {\n    // validation failed against value schema\n    if (input[key] === undefined) {\n      // if input was undefined, ignore the error\n      if (key in input) {\n        final.value[key] = undefined;\n      } else {\n        final.value[key] = result.value;\n      }\n    } else {\n      final.issues.push(...util.prefixIssues(key, result.issues));\n    }\n  } else if (result.value === undefined) {\n    // validation returned `undefined`\n    if (key in input) final.value[key] = undefined;\n  } else {\n    // non-undefined value\n    final.value[key] = result.value;\n  }\n}\nexport const $ZodObject = /*@__PURE__*/core.$constructor(\"$ZodObject\", (inst, def) => {\n  // requires cast because technically $ZodObject doesn't extend\n  $ZodType.init(inst, def);\n  const _normalized = util.cached(() => {\n    const keys = Object.keys(def.shape);\n    for (const k of keys) {\n      if (!(def.shape[k] instanceof $ZodType)) {\n        throw new Error(`Invalid element at key \"${k}\": expected a Zod schema`);\n      }\n    }\n    const okeys = util.optionalKeys(def.shape);\n    return {\n      shape: def.shape,\n      keys,\n      keySet: new Set(keys),\n      numKeys: keys.length,\n      optionalKeys: new Set(okeys)\n    };\n  });\n  util.defineLazy(inst._zod, \"propValues\", () => {\n    const shape = def.shape;\n    const propValues = {};\n    for (const key in shape) {\n      const field = shape[key]._zod;\n      if (field.values) {\n        propValues[key] ?? (propValues[key] = new Set());\n        for (const v of field.values) propValues[key].add(v);\n      }\n    }\n    return propValues;\n  });\n  const generateFastpass = shape => {\n    const doc = new Doc([\"shape\", \"payload\", \"ctx\"]);\n    const normalized = _normalized.value;\n    const parseStr = key => {\n      const k = util.esc(key);\n      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;\n    };\n    doc.write(`const input = payload.value;`);\n    const ids = Object.create(null);\n    let counter = 0;\n    for (const key of normalized.keys) {\n      ids[key] = `key_${counter++}`;\n    }\n    // A: preserve key order {\n    doc.write(`const newResult = {}`);\n    for (const key of normalized.keys) {\n      if (normalized.optionalKeys.has(key)) {\n        const id = ids[key];\n        doc.write(`const ${id} = ${parseStr(key)};`);\n        const k = util.esc(key);\n        doc.write(`\n        if (${id}.issues.length) {\n          if (input[${k}] === undefined) {\n            if (${k} in input) {\n              newResult[${k}] = undefined;\n            }\n          } else {\n            payload.issues = payload.issues.concat(\n              ${id}.issues.map((iss) => ({\n                ...iss,\n                path: iss.path ? [${k}, ...iss.path] : [${k}],\n              }))\n            );\n          }\n        } else if (${id}.value === undefined) {\n          if (${k} in input) newResult[${k}] = undefined;\n        } else {\n          newResult[${k}] = ${id}.value;\n        }\n        `);\n      } else {\n        const id = ids[key];\n        //  const id = ids[key];\n        doc.write(`const ${id} = ${parseStr(key)};`);\n        doc.write(`\n          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({\n            ...iss,\n            path: iss.path ? [${util.esc(key)}, ...iss.path] : [${util.esc(key)}]\n          })));`);\n        doc.write(`newResult[${util.esc(key)}] = ${id}.value`);\n      }\n    }\n    doc.write(`payload.value = newResult;`);\n    doc.write(`return payload;`);\n    const fn = doc.compile();\n    return (payload, ctx) => fn(shape, payload, ctx);\n  };\n  let fastpass;\n  const isObject = util.isObject;\n  const jit = !core.globalConfig.jitless;\n  const allowsEval = util.allowsEval;\n  const fastEnabled = jit && allowsEval.value; // && !def.catchall;\n  const catchall = def.catchall;\n  let value;\n  inst._zod.parse = (payload, ctx) => {\n    value ?? (value = _normalized.value);\n    const input = payload.value;\n    if (!isObject(input)) {\n      payload.issues.push({\n        expected: \"object\",\n        code: \"invalid_type\",\n        input,\n        inst\n      });\n      return payload;\n    }\n    const proms = [];\n    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {\n      // always synchronous\n      if (!fastpass) fastpass = generateFastpass(def.shape);\n      payload = fastpass(payload, ctx);\n    } else {\n      payload.value = {};\n      const shape = value.shape;\n      for (const key of value.keys) {\n        const el = shape[key];\n        // do not add omitted optional keys\n        // if (!(key in input)) {\n        //   if (optionalKeys.has(key)) continue;\n        //   payload.issues.push({\n        //     code: \"invalid_type\",\n        //     path: [key],\n        //     expected: \"nonoptional\",\n        //     note: `Missing required key: \"${key}\"`,\n        //     input,\n        //     inst,\n        //   });\n        // }\n        const r = el._zod.run({\n          value: input[key],\n          issues: []\n        }, ctx);\n        const isOptional = el._zod.optin === \"optional\" && el._zod.optout === \"optional\";\n        if (r instanceof Promise) {\n          proms.push(r.then(r => isOptional ? handleOptionalObjectResult(r, payload, key, input) : handleObjectResult(r, payload, key)));\n        } else if (isOptional) {\n          handleOptionalObjectResult(r, payload, key, input);\n        } else {\n          handleObjectResult(r, payload, key);\n        }\n      }\n    }\n    if (!catchall) {\n      // return payload;\n      return proms.length ? Promise.all(proms).then(() => payload) : payload;\n    }\n    const unrecognized = [];\n    // iterate over input keys\n    const keySet = value.keySet;\n    const _catchall = catchall._zod;\n    const t = _catchall.def.type;\n    for (const key of Object.keys(input)) {\n      if (keySet.has(key)) continue;\n      if (t === \"never\") {\n        unrecognized.push(key);\n        continue;\n      }\n      const r = _catchall.run({\n        value: input[key],\n        issues: []\n      }, ctx);\n      if (r instanceof Promise) {\n        proms.push(r.then(r => handleObjectResult(r, payload, key)));\n      } else {\n        handleObjectResult(r, payload, key);\n      }\n    }\n    if (unrecognized.length) {\n      payload.issues.push({\n        code: \"unrecognized_keys\",\n        keys: unrecognized,\n        input,\n        inst\n      });\n    }\n    if (!proms.length) return payload;\n    return Promise.all(proms).then(() => {\n      return payload;\n    });\n  };\n});\nfunction handleUnionResults(results, final, inst, ctx) {\n  for (const result of results) {\n    if (result.issues.length === 0) {\n      final.value = result.value;\n      return final;\n    }\n  }\n  final.issues.push({\n    code: \"invalid_union\",\n    input: final.value,\n    inst,\n    errors: results.map(result => result.issues.map(iss => util.finalizeIssue(iss, ctx, core.config())))\n  });\n  return final;\n}\nexport const $ZodUnion = /*@__PURE__*/core.$constructor(\"$ZodUnion\", (inst, def) => {\n  $ZodType.init(inst, def);\n  util.defineLazy(inst._zod, \"optin\", () => def.options.some(o => o._zod.optin === \"optional\") ? \"optional\" : undefined);\n  util.defineLazy(inst._zod, \"optout\", () => def.options.some(o => o._zod.optout === \"optional\") ? \"optional\" : undefined);\n  util.defineLazy(inst._zod, \"values\", () => {\n    if (def.options.every(o => o._zod.values)) {\n      return new Set(def.options.flatMap(option => Array.from(option._zod.values)));\n    }\n    return undefined;\n  });\n  util.defineLazy(inst._zod, \"pattern\", () => {\n    if (def.options.every(o => o._zod.pattern)) {\n      const patterns = def.options.map(o => o._zod.pattern);\n      return new RegExp(`^(${patterns.map(p => util.cleanRegex(p.source)).join(\"|\")})$`);\n    }\n    return undefined;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    let async = false;\n    const results = [];\n    for (const option of def.options) {\n      const result = option._zod.run({\n        value: payload.value,\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        results.push(result);\n        async = true;\n      } else {\n        if (result.issues.length === 0) return result;\n        results.push(result);\n      }\n    }\n    if (!async) return handleUnionResults(results, payload, inst, ctx);\n    return Promise.all(results).then(results => {\n      return handleUnionResults(results, payload, inst, ctx);\n    });\n  };\n});\nexport const $ZodDiscriminatedUnion = /*@__PURE__*/\ncore.$constructor(\"$ZodDiscriminatedUnion\", (inst, def) => {\n  $ZodUnion.init(inst, def);\n  const _super = inst._zod.parse;\n  util.defineLazy(inst._zod, \"propValues\", () => {\n    const propValues = {};\n    for (const option of def.options) {\n      const pv = option._zod.propValues;\n      if (!pv || Object.keys(pv).length === 0) throw new Error(`Invalid discriminated union option at index \"${def.options.indexOf(option)}\"`);\n      for (const [k, v] of Object.entries(pv)) {\n        if (!propValues[k]) propValues[k] = new Set();\n        for (const val of v) {\n          propValues[k].add(val);\n        }\n      }\n    }\n    return propValues;\n  });\n  const disc = util.cached(() => {\n    const opts = def.options;\n    const map = new Map();\n    for (const o of opts) {\n      const values = o._zod.propValues[def.discriminator];\n      if (!values || values.size === 0) throw new Error(`Invalid discriminated union option at index \"${def.options.indexOf(o)}\"`);\n      for (const v of values) {\n        if (map.has(v)) {\n          throw new Error(`Duplicate discriminator value \"${String(v)}\"`);\n        }\n        map.set(v, o);\n      }\n    }\n    return map;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!util.isObject(input)) {\n      payload.issues.push({\n        code: \"invalid_type\",\n        expected: \"object\",\n        input,\n        inst\n      });\n      return payload;\n    }\n    const opt = disc.value.get(input?.[def.discriminator]);\n    if (opt) {\n      return opt._zod.run(payload, ctx);\n    }\n    if (def.unionFallback) {\n      return _super(payload, ctx);\n    }\n    // no matching discriminator\n    payload.issues.push({\n      code: \"invalid_union\",\n      errors: [],\n      note: \"No matching discriminator\",\n      input,\n      path: [def.discriminator],\n      inst\n    });\n    return payload;\n  };\n});\nexport const $ZodIntersection = /*@__PURE__*/core.$constructor(\"$ZodIntersection\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    const left = def.left._zod.run({\n      value: input,\n      issues: []\n    }, ctx);\n    const right = def.right._zod.run({\n      value: input,\n      issues: []\n    }, ctx);\n    const async = left instanceof Promise || right instanceof Promise;\n    if (async) {\n      return Promise.all([left, right]).then(([left, right]) => {\n        return handleIntersectionResults(payload, left, right);\n      });\n    }\n    return handleIntersectionResults(payload, left, right);\n  };\n});\nfunction mergeValues(a, b) {\n  // const aType = parse.t(a);\n  // const bType = parse.t(b);\n  if (a === b) {\n    return {\n      valid: true,\n      data: a\n    };\n  }\n  if (a instanceof Date && b instanceof Date && +a === +b) {\n    return {\n      valid: true,\n      data: a\n    };\n  }\n  if (util.isPlainObject(a) && util.isPlainObject(b)) {\n    const bKeys = Object.keys(b);\n    const sharedKeys = Object.keys(a).filter(key => bKeys.indexOf(key) !== -1);\n    const newObj = {\n      ...a,\n      ...b\n    };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues(a[key], b[key]);\n      if (!sharedValue.valid) {\n        return {\n          valid: false,\n          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]\n        };\n      }\n      newObj[key] = sharedValue.data;\n    }\n    return {\n      valid: true,\n      data: newObj\n    };\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) {\n      return {\n        valid: false,\n        mergeErrorPath: []\n      };\n    }\n    const newArray = [];\n    for (let index = 0; index < a.length; index++) {\n      const itemA = a[index];\n      const itemB = b[index];\n      const sharedValue = mergeValues(itemA, itemB);\n      if (!sharedValue.valid) {\n        return {\n          valid: false,\n          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]\n        };\n      }\n      newArray.push(sharedValue.data);\n    }\n    return {\n      valid: true,\n      data: newArray\n    };\n  }\n  return {\n    valid: false,\n    mergeErrorPath: []\n  };\n}\nfunction handleIntersectionResults(result, left, right) {\n  if (left.issues.length) {\n    result.issues.push(...left.issues);\n  }\n  if (right.issues.length) {\n    result.issues.push(...right.issues);\n  }\n  if (util.aborted(result)) return result;\n  const merged = mergeValues(left.value, right.value);\n  if (!merged.valid) {\n    throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);\n  }\n  result.value = merged.data;\n  return result;\n}\nexport const $ZodTuple = /*@__PURE__*/core.$constructor(\"$ZodTuple\", (inst, def) => {\n  $ZodType.init(inst, def);\n  const items = def.items;\n  const optStart = items.length - [...items].reverse().findIndex(item => item._zod.optin !== \"optional\");\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!Array.isArray(input)) {\n      payload.issues.push({\n        input,\n        inst,\n        expected: \"tuple\",\n        code: \"invalid_type\"\n      });\n      return payload;\n    }\n    payload.value = [];\n    const proms = [];\n    if (!def.rest) {\n      const tooBig = input.length > items.length;\n      const tooSmall = input.length < optStart - 1;\n      if (tooBig || tooSmall) {\n        payload.issues.push({\n          input,\n          inst,\n          origin: \"array\",\n          ...(tooBig ? {\n            code: \"too_big\",\n            maximum: items.length\n          } : {\n            code: \"too_small\",\n            minimum: items.length\n          })\n        });\n        return payload;\n      }\n    }\n    let i = -1;\n    for (const item of items) {\n      i++;\n      if (i >= input.length) if (i >= optStart) continue;\n      const result = item._zod.run({\n        value: input[i],\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        proms.push(result.then(result => handleTupleResult(result, payload, i)));\n      } else {\n        handleTupleResult(result, payload, i);\n      }\n    }\n    if (def.rest) {\n      const rest = input.slice(items.length);\n      for (const el of rest) {\n        i++;\n        const result = def.rest._zod.run({\n          value: el,\n          issues: []\n        }, ctx);\n        if (result instanceof Promise) {\n          proms.push(result.then(result => handleTupleResult(result, payload, i)));\n        } else {\n          handleTupleResult(result, payload, i);\n        }\n      }\n    }\n    if (proms.length) return Promise.all(proms).then(() => payload);\n    return payload;\n  };\n});\nfunction handleTupleResult(result, final, index) {\n  if (result.issues.length) {\n    final.issues.push(...util.prefixIssues(index, result.issues));\n  }\n  final.value[index] = result.value;\n}\nexport const $ZodRecord = /*@__PURE__*/core.$constructor(\"$ZodRecord\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!util.isPlainObject(input)) {\n      payload.issues.push({\n        expected: \"record\",\n        code: \"invalid_type\",\n        input,\n        inst\n      });\n      return payload;\n    }\n    const proms = [];\n    if (def.keyType._zod.values) {\n      const values = def.keyType._zod.values;\n      payload.value = {};\n      for (const key of values) {\n        if (typeof key === \"string\" || typeof key === \"number\" || typeof key === \"symbol\") {\n          const result = def.valueType._zod.run({\n            value: input[key],\n            issues: []\n          }, ctx);\n          if (result instanceof Promise) {\n            proms.push(result.then(result => {\n              if (result.issues.length) {\n                payload.issues.push(...util.prefixIssues(key, result.issues));\n              }\n              payload.value[key] = result.value;\n            }));\n          } else {\n            if (result.issues.length) {\n              payload.issues.push(...util.prefixIssues(key, result.issues));\n            }\n            payload.value[key] = result.value;\n          }\n        }\n      }\n      let unrecognized;\n      for (const key in input) {\n        if (!values.has(key)) {\n          unrecognized = unrecognized ?? [];\n          unrecognized.push(key);\n        }\n      }\n      if (unrecognized && unrecognized.length > 0) {\n        payload.issues.push({\n          code: \"unrecognized_keys\",\n          input,\n          inst,\n          keys: unrecognized\n        });\n      }\n    } else {\n      payload.value = {};\n      for (const key of Reflect.ownKeys(input)) {\n        if (key === \"__proto__\") continue;\n        const keyResult = def.keyType._zod.run({\n          value: key,\n          issues: []\n        }, ctx);\n        if (keyResult instanceof Promise) {\n          throw new Error(\"Async schemas not supported in object keys currently\");\n        }\n        if (keyResult.issues.length) {\n          payload.issues.push({\n            origin: \"record\",\n            code: \"invalid_key\",\n            issues: keyResult.issues.map(iss => util.finalizeIssue(iss, ctx, core.config())),\n            input: key,\n            path: [key],\n            inst\n          });\n          payload.value[keyResult.value] = keyResult.value;\n          continue;\n        }\n        const result = def.valueType._zod.run({\n          value: input[key],\n          issues: []\n        }, ctx);\n        if (result instanceof Promise) {\n          proms.push(result.then(result => {\n            if (result.issues.length) {\n              payload.issues.push(...util.prefixIssues(key, result.issues));\n            }\n            payload.value[keyResult.value] = result.value;\n          }));\n        } else {\n          if (result.issues.length) {\n            payload.issues.push(...util.prefixIssues(key, result.issues));\n          }\n          payload.value[keyResult.value] = result.value;\n        }\n      }\n    }\n    if (proms.length) {\n      return Promise.all(proms).then(() => payload);\n    }\n    return payload;\n  };\n});\nexport const $ZodMap = /*@__PURE__*/core.$constructor(\"$ZodMap\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!(input instanceof Map)) {\n      payload.issues.push({\n        expected: \"map\",\n        code: \"invalid_type\",\n        input,\n        inst\n      });\n      return payload;\n    }\n    const proms = [];\n    payload.value = new Map();\n    for (const [key, value] of input) {\n      const keyResult = def.keyType._zod.run({\n        value: key,\n        issues: []\n      }, ctx);\n      const valueResult = def.valueType._zod.run({\n        value: value,\n        issues: []\n      }, ctx);\n      if (keyResult instanceof Promise || valueResult instanceof Promise) {\n        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult, valueResult]) => {\n          handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);\n        }));\n      } else {\n        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);\n      }\n    }\n    if (proms.length) return Promise.all(proms).then(() => payload);\n    return payload;\n  };\n});\nfunction handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {\n  if (keyResult.issues.length) {\n    if (util.propertyKeyTypes.has(typeof key)) {\n      final.issues.push(...util.prefixIssues(key, keyResult.issues));\n    } else {\n      final.issues.push({\n        origin: \"map\",\n        code: \"invalid_key\",\n        input,\n        inst,\n        issues: keyResult.issues.map(iss => util.finalizeIssue(iss, ctx, core.config()))\n      });\n    }\n  }\n  if (valueResult.issues.length) {\n    if (util.propertyKeyTypes.has(typeof key)) {\n      final.issues.push(...util.prefixIssues(key, valueResult.issues));\n    } else {\n      final.issues.push({\n        origin: \"map\",\n        code: \"invalid_element\",\n        input,\n        inst,\n        key: key,\n        issues: valueResult.issues.map(iss => util.finalizeIssue(iss, ctx, core.config()))\n      });\n    }\n  }\n  final.value.set(keyResult.value, valueResult.value);\n}\nexport const $ZodSet = /*@__PURE__*/core.$constructor(\"$ZodSet\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!(input instanceof Set)) {\n      payload.issues.push({\n        input,\n        inst,\n        expected: \"set\",\n        code: \"invalid_type\"\n      });\n      return payload;\n    }\n    const proms = [];\n    payload.value = new Set();\n    for (const item of input) {\n      const result = def.valueType._zod.run({\n        value: item,\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        proms.push(result.then(result => handleSetResult(result, payload)));\n      } else handleSetResult(result, payload);\n    }\n    if (proms.length) return Promise.all(proms).then(() => payload);\n    return payload;\n  };\n});\nfunction handleSetResult(result, final) {\n  if (result.issues.length) {\n    final.issues.push(...result.issues);\n  }\n  final.value.add(result.value);\n}\nexport const $ZodEnum = /*@__PURE__*/core.$constructor(\"$ZodEnum\", (inst, def) => {\n  $ZodType.init(inst, def);\n  const values = util.getEnumValues(def.entries);\n  inst._zod.values = new Set(values);\n  inst._zod.pattern = new RegExp(`^(${values.filter(k => util.propertyKeyTypes.has(typeof k)).map(o => typeof o === \"string\" ? util.escapeRegex(o) : o.toString()).join(\"|\")})$`);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (inst._zod.values.has(input)) {\n      return payload;\n    }\n    payload.issues.push({\n      code: \"invalid_value\",\n      values,\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nexport const $ZodLiteral = /*@__PURE__*/core.$constructor(\"$ZodLiteral\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.values = new Set(def.values);\n  inst._zod.pattern = new RegExp(`^(${def.values.map(o => typeof o === \"string\" ? util.escapeRegex(o) : o ? o.toString() : String(o)).join(\"|\")})$`);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (inst._zod.values.has(input)) {\n      return payload;\n    }\n    payload.issues.push({\n      code: \"invalid_value\",\n      values: def.values,\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nexport const $ZodFile = /*@__PURE__*/core.$constructor(\"$ZodFile\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (input instanceof File) return payload;\n    payload.issues.push({\n      expected: \"file\",\n      code: \"invalid_type\",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nexport const $ZodTransform = /*@__PURE__*/core.$constructor(\"$ZodTransform\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    const _out = def.transform(payload.value, payload);\n    if (_ctx.async) {\n      const output = _out instanceof Promise ? _out : Promise.resolve(_out);\n      return output.then(output => {\n        payload.value = output;\n        return payload;\n      });\n    }\n    if (_out instanceof Promise) {\n      throw new core.$ZodAsyncError();\n    }\n    payload.value = _out;\n    return payload;\n  };\n});\nexport const $ZodOptional = /*@__PURE__*/core.$constructor(\"$ZodOptional\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  inst._zod.optout = \"optional\";\n  util.defineLazy(inst._zod, \"values\", () => {\n    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;\n  });\n  util.defineLazy(inst._zod, \"pattern\", () => {\n    const pattern = def.innerType._zod.pattern;\n    return pattern ? new RegExp(`^(${util.cleanRegex(pattern.source)})?$`) : undefined;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    if (def.innerType._zod.optin === \"optional\") {\n      return def.innerType._zod.run(payload, ctx);\n    }\n    if (payload.value === undefined) {\n      return payload;\n    }\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nexport const $ZodNullable = /*@__PURE__*/core.$constructor(\"$ZodNullable\", (inst, def) => {\n  $ZodType.init(inst, def);\n  util.defineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n  util.defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n  util.defineLazy(inst._zod, \"pattern\", () => {\n    const pattern = def.innerType._zod.pattern;\n    return pattern ? new RegExp(`^(${util.cleanRegex(pattern.source)}|null)$`) : undefined;\n  });\n  util.defineLazy(inst._zod, \"values\", () => {\n    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    if (payload.value === null) return payload;\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nexport const $ZodDefault = /*@__PURE__*/core.$constructor(\"$ZodDefault\", (inst, def) => {\n  $ZodType.init(inst, def);\n  // inst._zod.qin = \"true\";\n  inst._zod.optin = \"optional\";\n  util.defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    if (payload.value === undefined) {\n      payload.value = def.defaultValue;\n      /**\n       * $ZodDefault always returns the default value immediately.\n       * It doesn't pass the default value into the validator (\"prefault\"). There's no reason to pass the default value through validation. The validity of the default is enforced by TypeScript statically. Otherwise, it's the responsibility of the user to ensure the default is valid. In the case of pipes with divergent in/out types, you can specify the default on the `in` schema of your ZodPipe to set a \"prefault\" for the pipe.   */\n      return payload;\n    }\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then(result => handleDefaultResult(result, def));\n    }\n    return handleDefaultResult(result, def);\n  };\n});\nfunction handleDefaultResult(payload, def) {\n  if (payload.value === undefined) {\n    payload.value = def.defaultValue;\n  }\n  return payload;\n}\nexport const $ZodPrefault = /*@__PURE__*/core.$constructor(\"$ZodPrefault\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  util.defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    if (payload.value === undefined) {\n      payload.value = def.defaultValue;\n    }\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nexport const $ZodNonOptional = /*@__PURE__*/core.$constructor(\"$ZodNonOptional\", (inst, def) => {\n  $ZodType.init(inst, def);\n  util.defineLazy(inst._zod, \"values\", () => {\n    const v = def.innerType._zod.values;\n    return v ? new Set([...v].filter(x => x !== undefined)) : undefined;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then(result => handleNonOptionalResult(result, inst));\n    }\n    return handleNonOptionalResult(result, inst);\n  };\n});\nfunction handleNonOptionalResult(payload, inst) {\n  if (!payload.issues.length && payload.value === undefined) {\n    payload.issues.push({\n      code: \"invalid_type\",\n      expected: \"nonoptional\",\n      input: payload.value,\n      inst\n    });\n  }\n  return payload;\n}\nexport const $ZodSuccess = /*@__PURE__*/core.$constructor(\"$ZodSuccess\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then(result => {\n        payload.value = result.issues.length === 0;\n        return payload;\n      });\n    }\n    payload.value = result.issues.length === 0;\n    return payload;\n  };\n});\nexport const $ZodCatch = /*@__PURE__*/core.$constructor(\"$ZodCatch\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  util.defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n  util.defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then(result => {\n        payload.value = result.value;\n        if (result.issues.length) {\n          payload.value = def.catchValue({\n            ...payload,\n            error: {\n              issues: result.issues.map(iss => util.finalizeIssue(iss, ctx, core.config()))\n            },\n            input: payload.value\n          });\n          payload.issues = [];\n        }\n        return payload;\n      });\n    }\n    payload.value = result.value;\n    if (result.issues.length) {\n      payload.value = def.catchValue({\n        ...payload,\n        error: {\n          issues: result.issues.map(iss => util.finalizeIssue(iss, ctx, core.config()))\n        },\n        input: payload.value\n      });\n      payload.issues = [];\n    }\n    return payload;\n  };\n});\nexport const $ZodNaN = /*@__PURE__*/core.$constructor(\"$ZodNaN\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    if (typeof payload.value !== \"number\" || !Number.isNaN(payload.value)) {\n      payload.issues.push({\n        input: payload.value,\n        inst,\n        expected: \"nan\",\n        code: \"invalid_type\"\n      });\n      return payload;\n    }\n    return payload;\n  };\n});\nexport const $ZodPipe = /*@__PURE__*/core.$constructor(\"$ZodPipe\", (inst, def) => {\n  $ZodType.init(inst, def);\n  util.defineLazy(inst._zod, \"values\", () => def.in._zod.values);\n  util.defineLazy(inst._zod, \"optin\", () => def.in._zod.optin);\n  util.defineLazy(inst._zod, \"optout\", () => def.out._zod.optout);\n  inst._zod.parse = (payload, ctx) => {\n    const left = def.in._zod.run(payload, ctx);\n    if (left instanceof Promise) {\n      return left.then(left => handlePipeResult(left, def, ctx));\n    }\n    return handlePipeResult(left, def, ctx);\n  };\n});\nfunction handlePipeResult(left, def, ctx) {\n  if (util.aborted(left)) {\n    return left;\n  }\n  return def.out._zod.run({\n    value: left.value,\n    issues: left.issues\n  }, ctx);\n}\nexport const $ZodReadonly = /*@__PURE__*/core.$constructor(\"$ZodReadonly\", (inst, def) => {\n  $ZodType.init(inst, def);\n  util.defineLazy(inst._zod, \"propValues\", () => def.innerType._zod.propValues);\n  util.defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  util.defineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n  util.defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then(handleReadonlyResult);\n    }\n    return handleReadonlyResult(result);\n  };\n});\nfunction handleReadonlyResult(payload) {\n  payload.value = Object.freeze(payload.value);\n  return payload;\n}\nexport const $ZodTemplateLiteral = /*@__PURE__*/core.$constructor(\"$ZodTemplateLiteral\", (inst, def) => {\n  $ZodType.init(inst, def);\n  const regexParts = [];\n  for (const part of def.parts) {\n    if (part instanceof $ZodType) {\n      if (!part._zod.pattern) {\n        // if (!source)\n        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);\n      }\n      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;\n      if (!source) throw new Error(`Invalid template literal part: ${part._zod.traits}`);\n      const start = source.startsWith(\"^\") ? 1 : 0;\n      const end = source.endsWith(\"$\") ? source.length - 1 : source.length;\n      regexParts.push(source.slice(start, end));\n    } else if (part === null || util.primitiveTypes.has(typeof part)) {\n      regexParts.push(util.escapeRegex(`${part}`));\n    } else {\n      throw new Error(`Invalid template literal part: ${part}`);\n    }\n  }\n  inst._zod.pattern = new RegExp(`^${regexParts.join(\"\")}$`);\n  inst._zod.parse = (payload, _ctx) => {\n    if (typeof payload.value !== \"string\") {\n      payload.issues.push({\n        input: payload.value,\n        inst,\n        expected: \"template_literal\",\n        code: \"invalid_type\"\n      });\n      return payload;\n    }\n    inst._zod.pattern.lastIndex = 0;\n    if (!inst._zod.pattern.test(payload.value)) {\n      payload.issues.push({\n        input: payload.value,\n        inst,\n        code: \"invalid_format\",\n        format: \"template_literal\",\n        pattern: inst._zod.pattern.source\n      });\n      return payload;\n    }\n    return payload;\n  };\n});\nexport const $ZodPromise = /*@__PURE__*/core.$constructor(\"$ZodPromise\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    return Promise.resolve(payload.value).then(inner => def.innerType._zod.run({\n      value: inner,\n      issues: []\n    }, ctx));\n  };\n});\nexport const $ZodLazy = /*@__PURE__*/core.$constructor(\"$ZodLazy\", (inst, def) => {\n  $ZodType.init(inst, def);\n  util.defineLazy(inst._zod, \"innerType\", () => def.getter());\n  util.defineLazy(inst._zod, \"pattern\", () => inst._zod.innerType._zod.pattern);\n  util.defineLazy(inst._zod, \"propValues\", () => inst._zod.innerType._zod.propValues);\n  util.defineLazy(inst._zod, \"optin\", () => inst._zod.innerType._zod.optin);\n  util.defineLazy(inst._zod, \"optout\", () => inst._zod.innerType._zod.optout);\n  inst._zod.parse = (payload, ctx) => {\n    const inner = inst._zod.innerType;\n    return inner._zod.run(payload, ctx);\n  };\n});\nexport const $ZodCustom = /*@__PURE__*/core.$constructor(\"$ZodCustom\", (inst, def) => {\n  checks.$ZodCheck.init(inst, def);\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _) => {\n    return payload;\n  };\n  inst._zod.check = payload => {\n    const input = payload.value;\n    const r = def.fn(input);\n    if (r instanceof Promise) {\n      return r.then(r => handleRefineResult(r, payload, input, inst));\n    }\n    handleRefineResult(r, payload, input, inst);\n    return;\n  };\n});\nfunction handleRefineResult(result, payload, input, inst) {\n  if (!result) {\n    const _iss = {\n      code: \"custom\",\n      input,\n      inst,\n      // incorporates params.error into issue reporting\n      path: [...(inst._zod.def.path ?? [])],\n      // incorporates params.error into issue reporting\n      continue: !inst._zod.def.abort\n      // params: inst._zod.def.params,\n    };\n    if (inst._zod.def.params) _iss.params = inst._zod.def.params;\n    payload.issues.push(util.issue(_iss));\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}