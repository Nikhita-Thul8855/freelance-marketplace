{"ast":null,"code":"import _objectSpread from \"C:/Users/PC/freelance-marketplace/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\n// import { $ZodType } from \"./schemas.js\";\nimport * as core from \"./core.js\";\nimport * as regexes from \"./regexes.js\";\nimport * as util from \"./util.js\";\nexport const $ZodCheck = /*@__PURE__*/core.$constructor(\"$ZodCheck\", (inst, def) => {\n  var _inst$_zod, _a$onattach;\n  var _a;\n  (_inst$_zod = inst._zod) !== null && _inst$_zod !== void 0 ? _inst$_zod : inst._zod = {};\n  inst._zod.def = def;\n  (_a$onattach = (_a = inst._zod).onattach) !== null && _a$onattach !== void 0 ? _a$onattach : _a.onattach = [];\n});\nconst numericOriginMap = {\n  number: \"number\",\n  bigint: \"bigint\",\n  object: \"date\"\n};\nexport const $ZodCheckLessThan = /*@__PURE__*/core.$constructor(\"$ZodCheckLessThan\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const origin = numericOriginMap[typeof def.value];\n  inst._zod.onattach.push(inst => {\n    var _ref;\n    const bag = inst._zod.bag;\n    const curr = (_ref = def.inclusive ? bag.maximum : bag.exclusiveMaximum) !== null && _ref !== void 0 ? _ref : Number.POSITIVE_INFINITY;\n    if (def.value < curr) {\n      if (def.inclusive) bag.maximum = def.value;else bag.exclusiveMaximum = def.value;\n    }\n  });\n  inst._zod.check = payload => {\n    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {\n      return;\n    }\n    payload.issues.push({\n      origin,\n      code: \"too_big\",\n      maximum: def.value,\n      input: payload.value,\n      inclusive: def.inclusive,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nexport const $ZodCheckGreaterThan = /*@__PURE__*/core.$constructor(\"$ZodCheckGreaterThan\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const origin = numericOriginMap[typeof def.value];\n  inst._zod.onattach.push(inst => {\n    var _ref2;\n    const bag = inst._zod.bag;\n    const curr = (_ref2 = def.inclusive ? bag.minimum : bag.exclusiveMinimum) !== null && _ref2 !== void 0 ? _ref2 : Number.NEGATIVE_INFINITY;\n    if (def.value > curr) {\n      if (def.inclusive) bag.minimum = def.value;else bag.exclusiveMinimum = def.value;\n    }\n  });\n  inst._zod.check = payload => {\n    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {\n      return;\n    }\n    payload.issues.push({\n      origin,\n      code: \"too_small\",\n      minimum: def.value,\n      input: payload.value,\n      inclusive: def.inclusive,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nexport const $ZodCheckMultipleOf = /*@__PURE__*/core.$constructor(\"$ZodCheckMultipleOf\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  inst._zod.onattach.push(inst => {\n    var _a$multipleOf;\n    var _a;\n    (_a$multipleOf = (_a = inst._zod.bag).multipleOf) !== null && _a$multipleOf !== void 0 ? _a$multipleOf : _a.multipleOf = def.value;\n  });\n  inst._zod.check = payload => {\n    if (typeof payload.value !== typeof def.value) throw new Error(\"Cannot mix number and bigint in multiple_of check.\");\n    const isMultiple = typeof payload.value === \"bigint\" ? payload.value % def.value === BigInt(0) : util.floatSafeRemainder(payload.value, def.value) === 0;\n    if (isMultiple) return;\n    payload.issues.push({\n      origin: typeof payload.value,\n      code: \"not_multiple_of\",\n      divisor: def.value,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nexport const $ZodCheckNumberFormat = /*@__PURE__*/core.$constructor(\"$ZodCheckNumberFormat\", (inst, def) => {\n  var _def$format;\n  $ZodCheck.init(inst, def); // no format checks\n  def.format = def.format || \"float64\";\n  const isInt = (_def$format = def.format) === null || _def$format === void 0 ? void 0 : _def$format.includes(\"int\");\n  const origin = isInt ? \"int\" : \"number\";\n  const [minimum, maximum] = util.NUMBER_FORMAT_RANGES[def.format];\n  inst._zod.onattach.push(inst => {\n    const bag = inst._zod.bag;\n    bag.format = def.format;\n    bag.minimum = minimum;\n    bag.maximum = maximum;\n    if (isInt) bag.pattern = regexes.integer;\n  });\n  inst._zod.check = payload => {\n    const input = payload.value;\n    if (isInt) {\n      if (!Number.isInteger(input)) {\n        // invalid_format issue\n        // payload.issues.push({\n        //   expected: def.format,\n        //   format: def.format,\n        //   code: \"invalid_format\",\n        //   input,\n        //   inst,\n        // });\n        // invalid_type issue\n        payload.issues.push({\n          expected: origin,\n          format: def.format,\n          code: \"invalid_type\",\n          input,\n          inst\n        });\n        return;\n        // not_multiple_of issue\n        // payload.issues.push({\n        //   code: \"not_multiple_of\",\n        //   origin: \"number\",\n        //   input,\n        //   inst,\n        //   divisor: 1,\n        // });\n      }\n      if (!Number.isSafeInteger(input)) {\n        if (input > 0) {\n          // too_big\n          payload.issues.push({\n            input,\n            code: \"too_big\",\n            maximum: Number.MAX_SAFE_INTEGER,\n            note: \"Integers must be within the safe integer range.\",\n            inst,\n            origin,\n            continue: !def.abort\n          });\n        } else {\n          // too_small\n          payload.issues.push({\n            input,\n            code: \"too_small\",\n            minimum: Number.MIN_SAFE_INTEGER,\n            note: \"Integers must be within the safe integer range.\",\n            inst,\n            origin,\n            continue: !def.abort\n          });\n        }\n        return;\n      }\n    }\n    if (input < minimum) {\n      payload.issues.push({\n        origin: \"number\",\n        input,\n        code: \"too_small\",\n        minimum,\n        inclusive: true,\n        inst,\n        continue: !def.abort\n      });\n    }\n    if (input > maximum) {\n      payload.issues.push({\n        origin: \"number\",\n        input,\n        code: \"too_big\",\n        maximum,\n        inst\n      });\n    }\n  };\n});\nexport const $ZodCheckBigIntFormat = /*@__PURE__*/core.$constructor(\"$ZodCheckBigIntFormat\", (inst, def) => {\n  $ZodCheck.init(inst, def); // no format checks\n  const [minimum, maximum] = util.BIGINT_FORMAT_RANGES[def.format];\n  inst._zod.onattach.push(inst => {\n    const bag = inst._zod.bag;\n    bag.format = def.format;\n    bag.minimum = minimum;\n    bag.maximum = maximum;\n  });\n  inst._zod.check = payload => {\n    const input = payload.value;\n    if (input < minimum) {\n      payload.issues.push({\n        origin: \"bigint\",\n        input,\n        code: \"too_small\",\n        minimum: minimum,\n        inclusive: true,\n        inst,\n        continue: !def.abort\n      });\n    }\n    if (input > maximum) {\n      payload.issues.push({\n        origin: \"bigint\",\n        input,\n        code: \"too_big\",\n        maximum,\n        inst\n      });\n    }\n  };\n});\nexport const $ZodCheckMaxSize = /*@__PURE__*/core.$constructor(\"$ZodCheckMaxSize\", (inst, def) => {\n  var _a$when;\n  var _a;\n  $ZodCheck.init(inst, def);\n  (_a$when = (_a = inst._zod.def).when) !== null && _a$when !== void 0 ? _a$when : _a.when = payload => {\n    const val = payload.value;\n    return !util.nullish(val) && val.size !== undefined;\n  };\n  inst._zod.onattach.push(inst => {\n    var _inst$_zod$bag$maximu;\n    const curr = (_inst$_zod$bag$maximu = inst._zod.bag.maximum) !== null && _inst$_zod$bag$maximu !== void 0 ? _inst$_zod$bag$maximu : Number.POSITIVE_INFINITY;\n    if (def.maximum < curr) inst._zod.bag.maximum = def.maximum;\n  });\n  inst._zod.check = payload => {\n    const input = payload.value;\n    const size = input.size;\n    if (size <= def.maximum) return;\n    payload.issues.push({\n      origin: util.getSizableOrigin(input),\n      code: \"too_big\",\n      maximum: def.maximum,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nexport const $ZodCheckMinSize = /*@__PURE__*/core.$constructor(\"$ZodCheckMinSize\", (inst, def) => {\n  var _a$when2;\n  var _a;\n  $ZodCheck.init(inst, def);\n  (_a$when2 = (_a = inst._zod.def).when) !== null && _a$when2 !== void 0 ? _a$when2 : _a.when = payload => {\n    const val = payload.value;\n    return !util.nullish(val) && val.size !== undefined;\n  };\n  inst._zod.onattach.push(inst => {\n    var _inst$_zod$bag$minimu;\n    const curr = (_inst$_zod$bag$minimu = inst._zod.bag.minimum) !== null && _inst$_zod$bag$minimu !== void 0 ? _inst$_zod$bag$minimu : Number.NEGATIVE_INFINITY;\n    if (def.minimum > curr) inst._zod.bag.minimum = def.minimum;\n  });\n  inst._zod.check = payload => {\n    const input = payload.value;\n    const size = input.size;\n    if (size >= def.minimum) return;\n    payload.issues.push({\n      origin: util.getSizableOrigin(input),\n      code: \"too_small\",\n      minimum: def.minimum,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nexport const $ZodCheckSizeEquals = /*@__PURE__*/core.$constructor(\"$ZodCheckSizeEquals\", (inst, def) => {\n  var _a$when3;\n  var _a;\n  $ZodCheck.init(inst, def);\n  (_a$when3 = (_a = inst._zod.def).when) !== null && _a$when3 !== void 0 ? _a$when3 : _a.when = payload => {\n    const val = payload.value;\n    return !util.nullish(val) && val.size !== undefined;\n  };\n  inst._zod.onattach.push(inst => {\n    const bag = inst._zod.bag;\n    bag.minimum = def.size;\n    bag.maximum = def.size;\n    bag.size = def.size;\n  });\n  inst._zod.check = payload => {\n    const input = payload.value;\n    const size = input.size;\n    if (size === def.size) return;\n    const tooBig = size > def.size;\n    payload.issues.push(_objectSpread(_objectSpread({\n      origin: util.getSizableOrigin(input)\n    }, tooBig ? {\n      code: \"too_big\",\n      maximum: def.size\n    } : {\n      code: \"too_small\",\n      minimum: def.size\n    }), {}, {\n      inclusive: true,\n      exact: true,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    }));\n  };\n});\nexport const $ZodCheckMaxLength = /*@__PURE__*/core.$constructor(\"$ZodCheckMaxLength\", (inst, def) => {\n  var _a$when4;\n  var _a;\n  $ZodCheck.init(inst, def);\n  (_a$when4 = (_a = inst._zod.def).when) !== null && _a$when4 !== void 0 ? _a$when4 : _a.when = payload => {\n    const val = payload.value;\n    return !util.nullish(val) && val.length !== undefined;\n  };\n  inst._zod.onattach.push(inst => {\n    var _inst$_zod$bag$maximu2;\n    const curr = (_inst$_zod$bag$maximu2 = inst._zod.bag.maximum) !== null && _inst$_zod$bag$maximu2 !== void 0 ? _inst$_zod$bag$maximu2 : Number.POSITIVE_INFINITY;\n    if (def.maximum < curr) inst._zod.bag.maximum = def.maximum;\n  });\n  inst._zod.check = payload => {\n    const input = payload.value;\n    const length = input.length;\n    if (length <= def.maximum) return;\n    const origin = util.getLengthableOrigin(input);\n    payload.issues.push({\n      origin,\n      code: \"too_big\",\n      maximum: def.maximum,\n      inclusive: true,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nexport const $ZodCheckMinLength = /*@__PURE__*/core.$constructor(\"$ZodCheckMinLength\", (inst, def) => {\n  var _a$when5;\n  var _a;\n  $ZodCheck.init(inst, def);\n  (_a$when5 = (_a = inst._zod.def).when) !== null && _a$when5 !== void 0 ? _a$when5 : _a.when = payload => {\n    const val = payload.value;\n    return !util.nullish(val) && val.length !== undefined;\n  };\n  inst._zod.onattach.push(inst => {\n    var _inst$_zod$bag$minimu2;\n    const curr = (_inst$_zod$bag$minimu2 = inst._zod.bag.minimum) !== null && _inst$_zod$bag$minimu2 !== void 0 ? _inst$_zod$bag$minimu2 : Number.NEGATIVE_INFINITY;\n    if (def.minimum > curr) inst._zod.bag.minimum = def.minimum;\n  });\n  inst._zod.check = payload => {\n    const input = payload.value;\n    const length = input.length;\n    if (length >= def.minimum) return;\n    const origin = util.getLengthableOrigin(input);\n    payload.issues.push({\n      origin,\n      code: \"too_small\",\n      minimum: def.minimum,\n      inclusive: true,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nexport const $ZodCheckLengthEquals = /*@__PURE__*/core.$constructor(\"$ZodCheckLengthEquals\", (inst, def) => {\n  var _a$when6;\n  var _a;\n  $ZodCheck.init(inst, def);\n  (_a$when6 = (_a = inst._zod.def).when) !== null && _a$when6 !== void 0 ? _a$when6 : _a.when = payload => {\n    const val = payload.value;\n    return !util.nullish(val) && val.length !== undefined;\n  };\n  inst._zod.onattach.push(inst => {\n    const bag = inst._zod.bag;\n    bag.minimum = def.length;\n    bag.maximum = def.length;\n    bag.length = def.length;\n  });\n  inst._zod.check = payload => {\n    const input = payload.value;\n    const length = input.length;\n    if (length === def.length) return;\n    const origin = util.getLengthableOrigin(input);\n    const tooBig = length > def.length;\n    payload.issues.push(_objectSpread(_objectSpread({\n      origin\n    }, tooBig ? {\n      code: \"too_big\",\n      maximum: def.length\n    } : {\n      code: \"too_small\",\n      minimum: def.length\n    }), {}, {\n      inclusive: true,\n      exact: true,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    }));\n  };\n});\nexport const $ZodCheckStringFormat = /*@__PURE__*/core.$constructor(\"$ZodCheckStringFormat\", (inst, def) => {\n  var _a$check, _b$check;\n  var _a, _b;\n  $ZodCheck.init(inst, def);\n  inst._zod.onattach.push(inst => {\n    const bag = inst._zod.bag;\n    bag.format = def.format;\n    if (def.pattern) {\n      var _bag$patterns;\n      (_bag$patterns = bag.patterns) !== null && _bag$patterns !== void 0 ? _bag$patterns : bag.patterns = new Set();\n      bag.patterns.add(def.pattern);\n    }\n  });\n  if (def.pattern) (_a$check = (_a = inst._zod).check) !== null && _a$check !== void 0 ? _a$check : _a.check = payload => {\n    def.pattern.lastIndex = 0;\n    if (def.pattern.test(payload.value)) return;\n    payload.issues.push(_objectSpread(_objectSpread({\n      origin: \"string\",\n      code: \"invalid_format\",\n      format: def.format,\n      input: payload.value\n    }, def.pattern ? {\n      pattern: def.pattern.toString()\n    } : {}), {}, {\n      inst,\n      continue: !def.abort\n    }));\n  };else (_b$check = (_b = inst._zod).check) !== null && _b$check !== void 0 ? _b$check : _b.check = () => {};\n});\nexport const $ZodCheckRegex = /*@__PURE__*/core.$constructor(\"$ZodCheckRegex\", (inst, def) => {\n  $ZodCheckStringFormat.init(inst, def);\n  inst._zod.check = payload => {\n    def.pattern.lastIndex = 0;\n    if (def.pattern.test(payload.value)) return;\n    payload.issues.push({\n      origin: \"string\",\n      code: \"invalid_format\",\n      format: \"regex\",\n      input: payload.value,\n      pattern: def.pattern.toString(),\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nexport const $ZodCheckLowerCase = /*@__PURE__*/core.$constructor(\"$ZodCheckLowerCase\", (inst, def) => {\n  var _def$pattern;\n  (_def$pattern = def.pattern) !== null && _def$pattern !== void 0 ? _def$pattern : def.pattern = regexes.lowercase;\n  $ZodCheckStringFormat.init(inst, def);\n});\nexport const $ZodCheckUpperCase = /*@__PURE__*/core.$constructor(\"$ZodCheckUpperCase\", (inst, def) => {\n  var _def$pattern2;\n  (_def$pattern2 = def.pattern) !== null && _def$pattern2 !== void 0 ? _def$pattern2 : def.pattern = regexes.uppercase;\n  $ZodCheckStringFormat.init(inst, def);\n});\nexport const $ZodCheckIncludes = /*@__PURE__*/core.$constructor(\"$ZodCheckIncludes\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const escapedRegex = util.escapeRegex(def.includes);\n  const pattern = new RegExp(typeof def.position === \"number\" ? \"^.{\".concat(def.position, \"}\").concat(escapedRegex) : escapedRegex);\n  def.pattern = pattern;\n  inst._zod.onattach.push(inst => {\n    var _bag$patterns2;\n    const bag = inst._zod.bag;\n    (_bag$patterns2 = bag.patterns) !== null && _bag$patterns2 !== void 0 ? _bag$patterns2 : bag.patterns = new Set();\n    bag.patterns.add(pattern);\n  });\n  inst._zod.check = payload => {\n    if (payload.value.includes(def.includes, def.position)) return;\n    payload.issues.push({\n      origin: \"string\",\n      code: \"invalid_format\",\n      format: \"includes\",\n      includes: def.includes,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nexport const $ZodCheckStartsWith = /*@__PURE__*/core.$constructor(\"$ZodCheckStartsWith\", (inst, def) => {\n  var _def$pattern3;\n  $ZodCheck.init(inst, def);\n  const pattern = new RegExp(\"^\".concat(util.escapeRegex(def.prefix), \".*\"));\n  (_def$pattern3 = def.pattern) !== null && _def$pattern3 !== void 0 ? _def$pattern3 : def.pattern = pattern;\n  inst._zod.onattach.push(inst => {\n    var _bag$patterns3;\n    const bag = inst._zod.bag;\n    (_bag$patterns3 = bag.patterns) !== null && _bag$patterns3 !== void 0 ? _bag$patterns3 : bag.patterns = new Set();\n    bag.patterns.add(pattern);\n  });\n  inst._zod.check = payload => {\n    if (payload.value.startsWith(def.prefix)) return;\n    payload.issues.push({\n      origin: \"string\",\n      code: \"invalid_format\",\n      format: \"starts_with\",\n      prefix: def.prefix,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nexport const $ZodCheckEndsWith = /*@__PURE__*/core.$constructor(\"$ZodCheckEndsWith\", (inst, def) => {\n  var _def$pattern4;\n  $ZodCheck.init(inst, def);\n  const pattern = new RegExp(\".*\".concat(util.escapeRegex(def.suffix), \"$\"));\n  (_def$pattern4 = def.pattern) !== null && _def$pattern4 !== void 0 ? _def$pattern4 : def.pattern = pattern;\n  inst._zod.onattach.push(inst => {\n    var _bag$patterns4;\n    const bag = inst._zod.bag;\n    (_bag$patterns4 = bag.patterns) !== null && _bag$patterns4 !== void 0 ? _bag$patterns4 : bag.patterns = new Set();\n    bag.patterns.add(pattern);\n  });\n  inst._zod.check = payload => {\n    if (payload.value.endsWith(def.suffix)) return;\n    payload.issues.push({\n      origin: \"string\",\n      code: \"invalid_format\",\n      format: \"ends_with\",\n      suffix: def.suffix,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\n///////////////////////////////////\n/////    $ZodCheckProperty    /////\n///////////////////////////////////\nfunction handleCheckPropertyResult(result, payload, property) {\n  if (result.issues.length) {\n    payload.issues.push(...util.prefixIssues(property, result.issues));\n  }\n}\nexport const $ZodCheckProperty = /*@__PURE__*/core.$constructor(\"$ZodCheckProperty\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  inst._zod.check = payload => {\n    const result = def.schema._zod.run({\n      value: payload.value[def.property],\n      issues: []\n    }, {});\n    if (result instanceof Promise) {\n      return result.then(result => handleCheckPropertyResult(result, payload, def.property));\n    }\n    handleCheckPropertyResult(result, payload, def.property);\n    return;\n  };\n});\nexport const $ZodCheckMimeType = /*@__PURE__*/core.$constructor(\"$ZodCheckMimeType\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const mimeSet = new Set(def.mime);\n  inst._zod.onattach.push(inst => {\n    inst._zod.bag.mime = def.mime;\n  });\n  inst._zod.check = payload => {\n    if (mimeSet.has(payload.value.type)) return;\n    payload.issues.push({\n      code: \"invalid_value\",\n      values: def.mime,\n      input: payload.value.type,\n      inst\n    });\n  };\n});\nexport const $ZodCheckOverwrite = /*@__PURE__*/core.$constructor(\"$ZodCheckOverwrite\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  inst._zod.check = payload => {\n    payload.value = def.tx(payload.value);\n  };\n});","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}