{"ast":null,"code":"import _objectSpread from \"C:/Users/PC/freelance-marketplace/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { $ZodRegistry, globalRegistry } from \"./registries.js\";\nimport { getEnumValues } from \"./util.js\";\nexport class JSONSchemaGenerator {\n  constructor(params) {\n    var _params$metadata, _params$target, _params$unrepresentab, _params$override, _params$io;\n    this.counter = 0;\n    this.metadataRegistry = (_params$metadata = params === null || params === void 0 ? void 0 : params.metadata) !== null && _params$metadata !== void 0 ? _params$metadata : globalRegistry;\n    this.target = (_params$target = params === null || params === void 0 ? void 0 : params.target) !== null && _params$target !== void 0 ? _params$target : \"draft-2020-12\";\n    this.unrepresentable = (_params$unrepresentab = params === null || params === void 0 ? void 0 : params.unrepresentable) !== null && _params$unrepresentab !== void 0 ? _params$unrepresentab : \"throw\";\n    this.override = (_params$override = params === null || params === void 0 ? void 0 : params.override) !== null && _params$override !== void 0 ? _params$override : () => {};\n    this.io = (_params$io = params === null || params === void 0 ? void 0 : params.io) !== null && _params$io !== void 0 ? _params$io : \"output\";\n    this.seen = new Map();\n  }\n  process(schema) {\n    var _schema$_zod$toJSONSc, _schema$_zod, _a$default;\n    let _params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      path: [],\n      schemaPath: []\n    };\n    var _a;\n    const def = schema._zod.def;\n    const formatMap = {\n      guid: \"uuid\",\n      url: \"uri\",\n      datetime: \"date-time\",\n      json_string: \"json-string\",\n      regex: \"\" // do not set\n    };\n    // check for schema in seens\n    const seen = this.seen.get(schema);\n    if (seen) {\n      seen.count++;\n      // check if cycle\n      const isCycle = _params.schemaPath.includes(schema);\n      if (isCycle) {\n        seen.cycle = _params.path;\n      }\n      return seen.schema;\n    }\n    // initialize\n    const result = {\n      schema: {},\n      count: 1,\n      cycle: undefined,\n      path: _params.path\n    };\n    this.seen.set(schema, result);\n    // custom method overrides default behavior\n    const overrideSchema = (_schema$_zod$toJSONSc = (_schema$_zod = schema._zod).toJSONSchema) === null || _schema$_zod$toJSONSc === void 0 ? void 0 : _schema$_zod$toJSONSc.call(_schema$_zod);\n    if (overrideSchema) {\n      result.schema = overrideSchema;\n    } else {\n      const params = _objectSpread(_objectSpread({}, _params), {}, {\n        schemaPath: [..._params.schemaPath, schema],\n        path: _params.path\n      });\n      const parent = schema._zod.parent;\n      if (parent) {\n        // schema was cloned from another schema\n        result.ref = parent;\n        this.process(parent, params);\n        this.seen.get(parent).isParent = true;\n      } else {\n        const _json = result.schema;\n        switch (def.type) {\n          case \"string\":\n            {\n              const json = _json;\n              json.type = \"string\";\n              const {\n                minimum,\n                maximum,\n                format,\n                patterns,\n                contentEncoding\n              } = schema._zod.bag;\n              if (typeof minimum === \"number\") json.minLength = minimum;\n              if (typeof maximum === \"number\") json.maxLength = maximum;\n              // custom pattern overrides format\n              if (format) {\n                var _formatMap$format;\n                json.format = (_formatMap$format = formatMap[format]) !== null && _formatMap$format !== void 0 ? _formatMap$format : format;\n                if (json.format === \"\") delete json.format; // empty format is not valid\n              }\n              if (contentEncoding) json.contentEncoding = contentEncoding;\n              if (patterns && patterns.size > 0) {\n                const regexes = [...patterns];\n                if (regexes.length === 1) json.pattern = regexes[0].source;else if (regexes.length > 1) {\n                  result.schema.allOf = [...regexes.map(regex => _objectSpread(_objectSpread({}, this.target === \"draft-7\" ? {\n                    type: \"string\"\n                  } : {}), {}, {\n                    pattern: regex.source\n                  }))];\n                }\n              }\n              break;\n            }\n          case \"number\":\n            {\n              const json = _json;\n              const {\n                minimum,\n                maximum,\n                format,\n                multipleOf,\n                exclusiveMaximum,\n                exclusiveMinimum\n              } = schema._zod.bag;\n              if (typeof format === \"string\" && format.includes(\"int\")) json.type = \"integer\";else json.type = \"number\";\n              if (typeof exclusiveMinimum === \"number\") json.exclusiveMinimum = exclusiveMinimum;\n              if (typeof minimum === \"number\") {\n                json.minimum = minimum;\n                if (typeof exclusiveMinimum === \"number\") {\n                  if (exclusiveMinimum >= minimum) delete json.minimum;else delete json.exclusiveMinimum;\n                }\n              }\n              if (typeof exclusiveMaximum === \"number\") json.exclusiveMaximum = exclusiveMaximum;\n              if (typeof maximum === \"number\") {\n                json.maximum = maximum;\n                if (typeof exclusiveMaximum === \"number\") {\n                  if (exclusiveMaximum <= maximum) delete json.maximum;else delete json.exclusiveMaximum;\n                }\n              }\n              if (typeof multipleOf === \"number\") json.multipleOf = multipleOf;\n              break;\n            }\n          case \"boolean\":\n            {\n              const json = _json;\n              json.type = \"boolean\";\n              break;\n            }\n          case \"bigint\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"BigInt cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"symbol\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Symbols cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"null\":\n            {\n              _json.type = \"null\";\n              break;\n            }\n          case \"any\":\n            {\n              break;\n            }\n          case \"unknown\":\n            {\n              break;\n            }\n          case \"undefined\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Undefined cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"void\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Void cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"never\":\n            {\n              _json.not = {};\n              break;\n            }\n          case \"date\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Date cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"array\":\n            {\n              const json = _json;\n              const {\n                minimum,\n                maximum\n              } = schema._zod.bag;\n              if (typeof minimum === \"number\") json.minItems = minimum;\n              if (typeof maximum === \"number\") json.maxItems = maximum;\n              json.type = \"array\";\n              json.items = this.process(def.element, _objectSpread(_objectSpread({}, params), {}, {\n                path: [...params.path, \"items\"]\n              }));\n              break;\n            }\n          case \"object\":\n            {\n              var _def$catchall;\n              const json = _json;\n              json.type = \"object\";\n              json.properties = {};\n              const shape = def.shape; // params.shapeCache.get(schema)!;\n              for (const key in shape) {\n                json.properties[key] = this.process(shape[key], _objectSpread(_objectSpread({}, params), {}, {\n                  path: [...params.path, \"properties\", key]\n                }));\n              }\n              // required keys\n              const allKeys = new Set(Object.keys(shape));\n              // const optionalKeys = new Set(def.optional);\n              const requiredKeys = new Set([...allKeys].filter(key => {\n                const v = def.shape[key]._zod;\n                if (this.io === \"input\") {\n                  return v.optin === undefined;\n                } else {\n                  return v.optout === undefined;\n                }\n              }));\n              if (requiredKeys.size > 0) {\n                json.required = Array.from(requiredKeys);\n              }\n              // catchall\n              if (((_def$catchall = def.catchall) === null || _def$catchall === void 0 ? void 0 : _def$catchall._zod.def.type) === \"never\") {\n                // strict\n                json.additionalProperties = false;\n              } else if (!def.catchall) {\n                // regular\n                if (this.io === \"output\") json.additionalProperties = false;\n              } else if (def.catchall) {\n                json.additionalProperties = this.process(def.catchall, _objectSpread(_objectSpread({}, params), {}, {\n                  path: [...params.path, \"additionalProperties\"]\n                }));\n              }\n              break;\n            }\n          case \"union\":\n            {\n              const json = _json;\n              json.anyOf = def.options.map((x, i) => this.process(x, _objectSpread(_objectSpread({}, params), {}, {\n                path: [...params.path, \"anyOf\", i]\n              })));\n              break;\n            }\n          case \"intersection\":\n            {\n              const json = _json;\n              const a = this.process(def.left, _objectSpread(_objectSpread({}, params), {}, {\n                path: [...params.path, \"allOf\", 0]\n              }));\n              const b = this.process(def.right, _objectSpread(_objectSpread({}, params), {}, {\n                path: [...params.path, \"allOf\", 1]\n              }));\n              const isSimpleIntersection = val => \"allOf\" in val && Object.keys(val).length === 1;\n              const allOf = [...(isSimpleIntersection(a) ? a.allOf : [a]), ...(isSimpleIntersection(b) ? b.allOf : [b])];\n              json.allOf = allOf;\n              break;\n            }\n          case \"tuple\":\n            {\n              const json = _json;\n              json.type = \"array\";\n              const prefixItems = def.items.map((x, i) => this.process(x, _objectSpread(_objectSpread({}, params), {}, {\n                path: [...params.path, \"prefixItems\", i]\n              })));\n              if (this.target === \"draft-2020-12\") {\n                json.prefixItems = prefixItems;\n              } else {\n                json.items = prefixItems;\n              }\n              if (def.rest) {\n                const rest = this.process(def.rest, _objectSpread(_objectSpread({}, params), {}, {\n                  path: [...params.path, \"items\"]\n                }));\n                if (this.target === \"draft-2020-12\") {\n                  json.items = rest;\n                } else {\n                  json.additionalItems = rest;\n                }\n              }\n              // additionalItems\n              if (def.rest) {\n                json.items = this.process(def.rest, _objectSpread(_objectSpread({}, params), {}, {\n                  path: [...params.path, \"items\"]\n                }));\n              }\n              // length\n              const {\n                minimum,\n                maximum\n              } = schema._zod.bag;\n              if (typeof minimum === \"number\") json.minItems = minimum;\n              if (typeof maximum === \"number\") json.maxItems = maximum;\n              break;\n            }\n          case \"record\":\n            {\n              const json = _json;\n              json.type = \"object\";\n              json.propertyNames = this.process(def.keyType, _objectSpread(_objectSpread({}, params), {}, {\n                path: [...params.path, \"propertyNames\"]\n              }));\n              json.additionalProperties = this.process(def.valueType, _objectSpread(_objectSpread({}, params), {}, {\n                path: [...params.path, \"additionalProperties\"]\n              }));\n              break;\n            }\n          case \"map\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Map cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"set\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Set cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"enum\":\n            {\n              const json = _json;\n              const values = getEnumValues(def.entries);\n              // Number enums can have both string and number values\n              if (values.every(v => typeof v === \"number\")) json.type = \"number\";\n              if (values.every(v => typeof v === \"string\")) json.type = \"string\";\n              json.enum = values;\n              break;\n            }\n          case \"literal\":\n            {\n              const json = _json;\n              const vals = [];\n              for (const val of def.values) {\n                if (val === undefined) {\n                  if (this.unrepresentable === \"throw\") {\n                    throw new Error(\"Literal `undefined` cannot be represented in JSON Schema\");\n                  } else {\n                    // do not add to vals\n                  }\n                } else if (typeof val === \"bigint\") {\n                  if (this.unrepresentable === \"throw\") {\n                    throw new Error(\"BigInt literals cannot be represented in JSON Schema\");\n                  } else {\n                    vals.push(Number(val));\n                  }\n                } else {\n                  vals.push(val);\n                }\n              }\n              if (vals.length === 0) {\n                // do nothing (an undefined literal was stripped)\n              } else if (vals.length === 1) {\n                const val = vals[0];\n                json.type = val === null ? \"null\" : typeof val;\n                json.const = val;\n              } else {\n                if (vals.every(v => typeof v === \"number\")) json.type = \"number\";\n                if (vals.every(v => typeof v === \"string\")) json.type = \"string\";\n                if (vals.every(v => typeof v === \"boolean\")) json.type = \"string\";\n                if (vals.every(v => v === null)) json.type = \"null\";\n                json.enum = vals;\n              }\n              break;\n            }\n          case \"file\":\n            {\n              const json = _json;\n              const file = {\n                type: \"string\",\n                format: \"binary\",\n                contentEncoding: \"binary\"\n              };\n              const {\n                minimum,\n                maximum,\n                mime\n              } = schema._zod.bag;\n              if (minimum !== undefined) file.minLength = minimum;\n              if (maximum !== undefined) file.maxLength = maximum;\n              if (mime) {\n                if (mime.length === 1) {\n                  file.contentMediaType = mime[0];\n                  Object.assign(json, file);\n                } else {\n                  json.anyOf = mime.map(m => {\n                    const mFile = _objectSpread(_objectSpread({}, file), {}, {\n                      contentMediaType: m\n                    });\n                    return mFile;\n                  });\n                }\n              } else {\n                Object.assign(json, file);\n              }\n              // if (this.unrepresentable === \"throw\") {\n              //   throw new Error(\"File cannot be represented in JSON Schema\");\n              // }\n              break;\n            }\n          case \"transform\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Transforms cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"nullable\":\n            {\n              const inner = this.process(def.innerType, params);\n              _json.anyOf = [inner, {\n                type: \"null\"\n              }];\n              break;\n            }\n          case \"nonoptional\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              break;\n            }\n          case \"success\":\n            {\n              const json = _json;\n              json.type = \"boolean\";\n              break;\n            }\n          case \"default\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              _json.default = JSON.parse(JSON.stringify(def.defaultValue));\n              break;\n            }\n          case \"prefault\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              if (this.io === \"input\") _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));\n              break;\n            }\n          case \"catch\":\n            {\n              // use conditionals\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              let catchValue;\n              try {\n                catchValue = def.catchValue(undefined);\n              } catch (_unused) {\n                throw new Error(\"Dynamic catch values are not supported in JSON Schema\");\n              }\n              _json.default = catchValue;\n              break;\n            }\n          case \"nan\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"NaN cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          case \"template_literal\":\n            {\n              const json = _json;\n              const pattern = schema._zod.pattern;\n              if (!pattern) throw new Error(\"Pattern not found in template literal\");\n              json.type = \"string\";\n              json.pattern = pattern.source;\n              break;\n            }\n          case \"pipe\":\n            {\n              const innerType = this.io === \"input\" ? def.in._zod.def.type === \"transform\" ? def.out : def.in : def.out;\n              this.process(innerType, params);\n              result.ref = innerType;\n              break;\n            }\n          case \"readonly\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              _json.readOnly = true;\n              break;\n            }\n          // passthrough types\n          case \"promise\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              break;\n            }\n          case \"optional\":\n            {\n              this.process(def.innerType, params);\n              result.ref = def.innerType;\n              break;\n            }\n          case \"lazy\":\n            {\n              const innerType = schema._zod.innerType;\n              this.process(innerType, params);\n              result.ref = innerType;\n              break;\n            }\n          case \"custom\":\n            {\n              if (this.unrepresentable === \"throw\") {\n                throw new Error(\"Custom types cannot be represented in JSON Schema\");\n              }\n              break;\n            }\n          default:\n            {\n              def;\n            }\n        }\n      }\n    }\n    // metadata\n    const meta = this.metadataRegistry.get(schema);\n    if (meta) Object.assign(result.schema, meta);\n    if (this.io === \"input\" && isTransforming(schema)) {\n      // examples/defaults only apply to output type of pipe\n      delete result.schema.examples;\n      delete result.schema.default;\n    }\n    // set prefault as default\n    if (this.io === \"input\" && result.schema._prefault) (_a$default = (_a = result.schema).default) !== null && _a$default !== void 0 ? _a$default : _a.default = result.schema._prefault;\n    delete result.schema._prefault;\n    // pulling fresh from this.seen in case it was overwritten\n    const _result = this.seen.get(schema);\n    return _result.schema;\n  }\n  emit(schema, _params) {\n    var _params$cycles, _params$reused, _params$external, _params$external2, _params$external$defs, _params$external3;\n    const params = {\n      cycles: (_params$cycles = _params === null || _params === void 0 ? void 0 : _params.cycles) !== null && _params$cycles !== void 0 ? _params$cycles : \"ref\",\n      reused: (_params$reused = _params === null || _params === void 0 ? void 0 : _params.reused) !== null && _params$reused !== void 0 ? _params$reused : \"inline\",\n      // unrepresentable: _params?.unrepresentable ?? \"throw\",\n      // uri: _params?.uri ?? ((id) => `${id}`),\n      external: (_params$external = _params === null || _params === void 0 ? void 0 : _params.external) !== null && _params$external !== void 0 ? _params$external : undefined\n    };\n    // iterate over seen map;\n    const root = this.seen.get(schema);\n    if (!root) throw new Error(\"Unprocessed schema. This is a bug in Zod.\");\n    // initialize result with root schema fields\n    // Object.assign(result, seen.cached);\n    // returns a ref to the schema\n    // defId will be empty if the ref points to an external schema (or #)\n    const makeURI = entry => {\n      var _entry$1$schema$id;\n      // comparing the seen objects because sometimes\n      // multiple schemas map to the same seen object.\n      // e.g. lazy\n      // external is configured\n      const defsSegment = this.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n      if (params.external) {\n        var _params$external$regi, _params$external$uri, _ref, _entry$1$defId;\n        const externalId = (_params$external$regi = params.external.registry.get(entry[0])) === null || _params$external$regi === void 0 ? void 0 : _params$external$regi.id; // ?? \"__shared\";// `__schema${this.counter++}`;\n        // check if schema is in the external registry\n        const uriGenerator = (_params$external$uri = params.external.uri) !== null && _params$external$uri !== void 0 ? _params$external$uri : id => id;\n        if (externalId) {\n          return {\n            ref: uriGenerator(externalId)\n          };\n        }\n        // otherwise, add to __shared\n        const id = (_ref = (_entry$1$defId = entry[1].defId) !== null && _entry$1$defId !== void 0 ? _entry$1$defId : entry[1].schema.id) !== null && _ref !== void 0 ? _ref : \"schema\".concat(this.counter++);\n        entry[1].defId = id; // set defId so it will be reused if needed\n        return {\n          defId: id,\n          ref: \"\".concat(uriGenerator(\"__shared\"), \"#/\").concat(defsSegment, \"/\").concat(id)\n        };\n      }\n      if (entry[1] === root) {\n        return {\n          ref: \"#\"\n        };\n      }\n      // self-contained schema\n      const uriPrefix = \"#\";\n      const defUriPrefix = \"\".concat(uriPrefix, \"/\").concat(defsSegment, \"/\");\n      const defId = (_entry$1$schema$id = entry[1].schema.id) !== null && _entry$1$schema$id !== void 0 ? _entry$1$schema$id : \"__schema\".concat(this.counter++);\n      return {\n        defId,\n        ref: defUriPrefix + defId\n      };\n    };\n    // stored cached version in `def` property\n    // remove all properties, set $ref\n    const extractToDef = entry => {\n      // if the schema is already a reference, do not extract it\n      if (entry[1].schema.$ref) {\n        return;\n      }\n      const seen = entry[1];\n      const {\n        ref,\n        defId\n      } = makeURI(entry);\n      seen.def = _objectSpread({}, seen.schema);\n      // defId won't be set if the schema is a reference to an external schema\n      if (defId) seen.defId = defId;\n      // wipe away all properties except $ref\n      const schema = seen.schema;\n      for (const key in schema) {\n        delete schema[key];\n      }\n      schema.$ref = ref;\n    };\n    // throw on cycles\n    // break cycles\n    if (params.cycles === \"throw\") {\n      for (const entry of this.seen.entries()) {\n        const seen = entry[1];\n        if (seen.cycle) {\n          var _seen$cycle;\n          throw new Error(\"Cycle detected: \" + \"#/\".concat((_seen$cycle = seen.cycle) === null || _seen$cycle === void 0 ? void 0 : _seen$cycle.join(\"/\"), \"/<root>\") + '\\n\\nSet the `cycles` parameter to `\"ref\"` to resolve cyclical schemas with defs.');\n        }\n      }\n    }\n    // extract schemas into $defs\n    for (const entry of this.seen.entries()) {\n      var _this$metadataRegistr;\n      const seen = entry[1];\n      // convert root schema to # $ref\n      if (schema === entry[0]) {\n        extractToDef(entry); // this has special handling for the root schema\n        continue;\n      }\n      // extract schemas that are in the external registry\n      if (params.external) {\n        var _params$external$regi2;\n        const ext = (_params$external$regi2 = params.external.registry.get(entry[0])) === null || _params$external$regi2 === void 0 ? void 0 : _params$external$regi2.id;\n        if (schema !== entry[0] && ext) {\n          extractToDef(entry);\n          continue;\n        }\n      }\n      // extract schemas with `id` meta\n      const id = (_this$metadataRegistr = this.metadataRegistry.get(entry[0])) === null || _this$metadataRegistr === void 0 ? void 0 : _this$metadataRegistr.id;\n      if (id) {\n        extractToDef(entry);\n        continue;\n      }\n      // break cycles\n      if (seen.cycle) {\n        // any\n        extractToDef(entry);\n        continue;\n      }\n      // extract reused schemas\n      if (seen.count > 1) {\n        if (params.reused === \"ref\") {\n          extractToDef(entry);\n          // biome-ignore lint:\n          continue;\n        }\n      }\n    }\n    // flatten _refs\n    const flattenRef = (zodSchema, params) => {\n      var _seen$def, _seen$path;\n      const seen = this.seen.get(zodSchema);\n      const schema = (_seen$def = seen.def) !== null && _seen$def !== void 0 ? _seen$def : seen.schema;\n      const _cached = _objectSpread({}, schema);\n      // already seen\n      if (seen.ref === null) {\n        return;\n      }\n      // flatten ref if defined\n      const ref = seen.ref;\n      seen.ref = null; // prevent recursion\n      if (ref) {\n        flattenRef(ref, params);\n        // merge referenced schema into current\n        const refSchema = this.seen.get(ref).schema;\n        if (refSchema.$ref && params.target === \"draft-7\") {\n          var _schema$allOf;\n          schema.allOf = (_schema$allOf = schema.allOf) !== null && _schema$allOf !== void 0 ? _schema$allOf : [];\n          schema.allOf.push(refSchema);\n        } else {\n          Object.assign(schema, refSchema);\n          Object.assign(schema, _cached); // prevent overwriting any fields in the original schema\n        }\n      }\n      // execute overrides\n      if (!seen.isParent) this.override({\n        zodSchema: zodSchema,\n        jsonSchema: schema,\n        path: (_seen$path = seen.path) !== null && _seen$path !== void 0 ? _seen$path : []\n      });\n    };\n    for (const entry of [...this.seen.entries()].reverse()) {\n      flattenRef(entry[0], {\n        target: this.target\n      });\n    }\n    const result = {};\n    if (this.target === \"draft-2020-12\") {\n      result.$schema = \"https://json-schema.org/draft/2020-12/schema\";\n    } else if (this.target === \"draft-7\") {\n      result.$schema = \"http://json-schema.org/draft-07/schema#\";\n    } else {\n      console.warn(\"Invalid target: \".concat(this.target));\n    }\n    if ((_params$external2 = params.external) !== null && _params$external2 !== void 0 && _params$external2.uri) {\n      var _params$external$regi3;\n      const id = (_params$external$regi3 = params.external.registry.get(schema)) === null || _params$external$regi3 === void 0 ? void 0 : _params$external$regi3.id;\n      if (!id) throw new Error(\"Schema is missing an `id` property\");\n      result.$id = params.external.uri(id);\n    }\n    Object.assign(result, root.def);\n    // build defs object\n    const defs = (_params$external$defs = (_params$external3 = params.external) === null || _params$external3 === void 0 ? void 0 : _params$external3.defs) !== null && _params$external$defs !== void 0 ? _params$external$defs : {};\n    for (const entry of this.seen.entries()) {\n      const seen = entry[1];\n      if (seen.def && seen.defId) {\n        defs[seen.defId] = seen.def;\n      }\n    }\n    // set definitions in result\n    if (params.external) {} else {\n      if (Object.keys(defs).length > 0) {\n        if (this.target === \"draft-2020-12\") {\n          result.$defs = defs;\n        } else {\n          result.definitions = defs;\n        }\n      }\n    }\n    try {\n      // this \"finalizes\" this schema and ensures all cycles are removed\n      // each call to .emit() is functionally independent\n      // though the seen map is shared\n      return JSON.parse(JSON.stringify(result));\n    } catch (_err) {\n      throw new Error(\"Error converting schema to JSON.\");\n    }\n  }\n}\nexport function toJSONSchema(input, _params) {\n  if (input instanceof $ZodRegistry) {\n    const gen = new JSONSchemaGenerator(_params);\n    const defs = {};\n    for (const entry of input._idmap.entries()) {\n      const [_, schema] = entry;\n      gen.process(schema);\n    }\n    const schemas = {};\n    const external = {\n      registry: input,\n      uri: _params === null || _params === void 0 ? void 0 : _params.uri,\n      defs\n    };\n    for (const entry of input._idmap.entries()) {\n      const [key, schema] = entry;\n      schemas[key] = gen.emit(schema, _objectSpread(_objectSpread({}, _params), {}, {\n        external\n      }));\n    }\n    if (Object.keys(defs).length > 0) {\n      const defsSegment = gen.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n      schemas.__shared = {\n        [defsSegment]: defs\n      };\n    }\n    return {\n      schemas\n    };\n  }\n  const gen = new JSONSchemaGenerator(_params);\n  gen.process(input);\n  return gen.emit(input, _params);\n}\nfunction isTransforming(_schema, _ctx) {\n  const ctx = _ctx !== null && _ctx !== void 0 ? _ctx : {\n    seen: new Set()\n  };\n  if (ctx.seen.has(_schema)) return false;\n  ctx.seen.add(_schema);\n  const schema = _schema;\n  const def = schema._zod.def;\n  switch (def.type) {\n    case \"string\":\n    case \"number\":\n    case \"bigint\":\n    case \"boolean\":\n    case \"date\":\n    case \"symbol\":\n    case \"undefined\":\n    case \"null\":\n    case \"any\":\n    case \"unknown\":\n    case \"never\":\n    case \"void\":\n    case \"literal\":\n    case \"enum\":\n    case \"nan\":\n    case \"file\":\n    case \"template_literal\":\n      return false;\n    case \"array\":\n      {\n        return isTransforming(def.element, ctx);\n      }\n    case \"object\":\n      {\n        for (const key in def.shape) {\n          if (isTransforming(def.shape[key], ctx)) return true;\n        }\n        return false;\n      }\n    case \"union\":\n      {\n        for (const option of def.options) {\n          if (isTransforming(option, ctx)) return true;\n        }\n        return false;\n      }\n    case \"intersection\":\n      {\n        return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);\n      }\n    case \"tuple\":\n      {\n        for (const item of def.items) {\n          if (isTransforming(item, ctx)) return true;\n        }\n        if (def.rest && isTransforming(def.rest, ctx)) return true;\n        return false;\n      }\n    case \"record\":\n      {\n        return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n      }\n    case \"map\":\n      {\n        return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n      }\n    case \"set\":\n      {\n        return isTransforming(def.valueType, ctx);\n      }\n    // inner types\n    case \"promise\":\n    case \"optional\":\n    case \"nonoptional\":\n    case \"nullable\":\n    case \"readonly\":\n      return isTransforming(def.innerType, ctx);\n    case \"lazy\":\n      return isTransforming(def.getter(), ctx);\n    case \"default\":\n      {\n        return isTransforming(def.innerType, ctx);\n      }\n    case \"prefault\":\n      {\n        return isTransforming(def.innerType, ctx);\n      }\n    case \"custom\":\n      {\n        return false;\n      }\n    case \"transform\":\n      {\n        return true;\n      }\n    case \"pipe\":\n      {\n        return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);\n      }\n    case \"success\":\n      {\n        return false;\n      }\n    case \"catch\":\n      {\n        return false;\n      }\n    default:\n      def;\n  }\n  throw new Error(\"Unknown schema type: \".concat(def.type));\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}