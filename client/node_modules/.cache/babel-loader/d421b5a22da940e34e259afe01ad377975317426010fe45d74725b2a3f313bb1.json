{"ast":null,"code":"import { validateFieldsNatively as r, toNestErrors as e } from \"@hookform/resolvers\";\nimport { appendErrors as o } from \"react-hook-form\";\nimport * as n from \"zod/v4/core\";\nfunction t(r, e) {\n  try {\n    var o = r();\n  } catch (r) {\n    return e(r);\n  }\n  return o && o.then ? o.then(void 0, e) : o;\n}\nfunction s(r, e) {\n  for (var n = {}; r.length;) {\n    var t = r[0],\n      s = t.code,\n      i = t.message,\n      a = t.path.join(\".\");\n    if (!n[a]) if (\"unionErrors\" in t) {\n      var u = t.unionErrors[0].errors[0];\n      n[a] = {\n        message: u.message,\n        type: u.code\n      };\n    } else n[a] = {\n      message: i,\n      type: s\n    };\n    if (\"unionErrors\" in t && t.unionErrors.forEach(function (e) {\n      return e.errors.forEach(function (e) {\n        return r.push(e);\n      });\n    }), e) {\n      var c = n[a].types,\n        f = c && c[t.code];\n      n[a] = o(a, e, n, s, f ? [].concat(f, t.message) : t.message);\n    }\n    r.shift();\n  }\n  return n;\n}\nfunction i(r, e) {\n  for (var n = {}; r.length;) {\n    var t = r[0],\n      s = t.code,\n      i = t.message,\n      a = t.path.join(\".\");\n    if (!n[a]) if (\"invalid_union\" === t.code) {\n      var u = t.errors[0][0];\n      n[a] = {\n        message: u.message,\n        type: u.code\n      };\n    } else n[a] = {\n      message: i,\n      type: s\n    };\n    if (\"invalid_union\" === t.code && t.errors.forEach(function (e) {\n      return e.forEach(function (e) {\n        return r.push(e);\n      });\n    }), e) {\n      var c = n[a].types,\n        f = c && c[t.code];\n      n[a] = o(a, e, n, s, f ? [].concat(f, t.message) : t.message);\n    }\n    r.shift();\n  }\n  return n;\n}\nfunction a(o, a, u) {\n  if (void 0 === u && (u = {}), function (r) {\n    return \"_def\" in r && \"object\" == typeof r._def && \"typeName\" in r._def;\n  }(o)) return function (n, i, c) {\n    try {\n      return Promise.resolve(t(function () {\n        return Promise.resolve(o[\"sync\" === u.mode ? \"parse\" : \"parseAsync\"](n, a)).then(function (e) {\n          return c.shouldUseNativeValidation && r({}, c), {\n            errors: {},\n            values: u.raw ? Object.assign({}, n) : e\n          };\n        });\n      }, function (r) {\n        if (function (r) {\n          return Array.isArray(null == r ? void 0 : r.issues);\n        }(r)) return {\n          values: {},\n          errors: e(s(r.errors, !c.shouldUseNativeValidation && \"all\" === c.criteriaMode), c)\n        };\n        throw r;\n      }));\n    } catch (r) {\n      return Promise.reject(r);\n    }\n  };\n  if (function (r) {\n    return \"_zod\" in r && \"object\" == typeof r._zod;\n  }(o)) return function (s, c, f) {\n    try {\n      return Promise.resolve(t(function () {\n        return Promise.resolve((\"sync\" === u.mode ? n.parse : n.parseAsync)(o, s, a)).then(function (e) {\n          return f.shouldUseNativeValidation && r({}, f), {\n            errors: {},\n            values: u.raw ? Object.assign({}, s) : e\n          };\n        });\n      }, function (r) {\n        if (function (r) {\n          return r instanceof n.$ZodError;\n        }(r)) return {\n          values: {},\n          errors: e(i(r.issues, !f.shouldUseNativeValidation && \"all\" === f.criteriaMode), f)\n        };\n        throw r;\n      }));\n    } catch (r) {\n      return Promise.reject(r);\n    }\n  };\n  throw new Error(\"Invalid input: not a Zod schema\");\n}\nexport { a as zodResolver };\n//# sourceMappingURL=zod.module.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}